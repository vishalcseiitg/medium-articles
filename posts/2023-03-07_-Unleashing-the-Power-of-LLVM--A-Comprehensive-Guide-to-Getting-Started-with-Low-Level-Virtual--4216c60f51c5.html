<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>“Unleashing the Power of LLVM: A Comprehensive Guide to Getting Started with Low-Level Virtual…</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">“Unleashing the Power of LLVM: A Comprehensive Guide to Getting Started with Low-Level Virtual…</h1>
</header>
<section data-field="subtitle" class="p-summary">
LLVM stands for Low-Level Virtual Machine, an open-source compiler infrastructure project. Its purpose is to provide a collection of…
</section>
<section data-field="body" class="e-content">
<section name="2bf7" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="d4d0" id="d4d0" class="graf graf--h3 graf--startsWithDoubleQuote graf--leading graf--title">“Unleashing the Power of LLVM: A Comprehensive Guide to Getting Started with Low-Level Virtual Machine”</h3><figure name="47dc" id="47dc" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*2MY_gsqbyZGF8_gvXB0ZBQ.png" data-width="399" data-height="250" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*2MY_gsqbyZGF8_gvXB0ZBQ.png"><figcaption class="imageCaption">LLVM Logo</figcaption></figure><p name="6fc9" id="6fc9" class="graf graf--p graf-after--figure">LLVM stands for Low-Level Virtual Machine, an open-source compiler infrastructure project. Its purpose is to provide a collection of modular and reusable compiler and toolchain technologies that can be used to develop front ends for different programming languages and back ends for various hardware architectures. LLVM has gained immense popularity in the software development world due to its robustness, flexibility, and portability. It has been used in various projects, including operating systems, web browsers, video games, and programming languages. LLVM has also been a foundation for several other popular software development tools, such as Clang, Rust, Swift, and CUDA. Its modular design allows developers to integrate it into their projects easily and benefit from its performance optimizations and code generation capabilities.</p><p name="be4e" id="be4e" class="graf graf--p graf-after--p">Installing LLVM can be done in several ways, and in this section, we will cover the three most common methods: installing pre-built packages, building from source, and using a package manager.</p><ol class="postList"><li name="aa00" id="aa00" class="graf graf--li graf-after--p">Installing Pre-built Packages:</li></ol><p name="539a" id="539a" class="graf graf--p graf-after--li">The easiest way to install LLVM is using pre-built packages for the most popular operating systems. To install LLVM on your system using pre-built packages, follow these steps:</p><ul class="postList"><li name="19a5" id="19a5" class="graf graf--li graf-after--p">Visit the LLVM official website at <a href="https://llvm.org/releases/download.html" data-href="https://llvm.org/releases/download.html" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">https://llvm.org/releases/download.html</a> and select the appropriate package for your operating system.</li><li name="bbb9" id="bbb9" class="graf graf--li graf-after--li">Download the package and extract it to a directory of your choice.</li><li name="079a" id="079a" class="graf graf--li graf-after--li">Add the extracted directory to your system’s PATH environment variable to enable access to LLVM’s tools.</li><li name="c470" id="c470" class="graf graf--li graf-after--li">Verify the installation by running the “llvm-config — version” command in your terminal, which should display the installed LLVM version.</li></ul><ol class="postList"><li name="aadf" id="aadf" class="graf graf--li graf-after--li">Building from Source:</li></ol><p name="4750" id="4750" class="graf graf--p graf-after--li">Building LLVM from source is a more advanced installation method that requires installing dependencies and compiling LLVM’s source code. To install LLVM from source, follow these steps:</p><ul class="postList"><li name="62c1" id="62c1" class="graf graf--li graf-after--p">Install the required dependencies, which vary depending on your operating system. You can find a list of dependencies for each supported platform on the LLVM official website.</li><li name="fef8" id="fef8" class="graf graf--li graf-after--li">Download the LLVM source code from <a href="https://llvm.org/releases/download.html" data-href="https://llvm.org/releases/download.html" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">https://llvm.org/releases/download.html</a>.</li><li name="8239" id="8239" class="graf graf--li graf-after--li">Extract the source code to a directory of your choice.</li><li name="6a9e" id="6a9e" class="graf graf--li graf-after--li">Create a build directory and navigate to it in your terminal.</li><li name="2b2f" id="2b2f" class="graf graf--li graf-after--li">Run the “cmake &lt;path_to_llvm_source&gt;” command to configure LLVM with the appropriate options for your system.</li><li name="1ea5" id="1ea5" class="graf graf--li graf-after--li">Run the “make” command to build LLVM.</li><li name="5eb0" id="5eb0" class="graf graf--li graf-after--li">Install LLVM by running the “make install” command.</li></ul><ol class="postList"><li name="9d88" id="9d88" class="graf graf--li graf-after--li">Using a Package Manager:</li></ol><p name="4c0e" id="4c0e" class="graf graf--p graf-after--li">Using a package manager is the most convenient method to install LLVM, as it automates the installation process and handles dependencies. However, this method may not be available for all operating systems. To install LLVM using a package manager, follow these steps:</p><ul class="postList"><li name="22d2" id="22d2" class="graf graf--li graf-after--p">Update your system’s package manager and repository.</li><li name="aabd" id="aabd" class="graf graf--li graf-after--li">Search for the LLVM package using your system’s package manager.</li><li name="7456" id="7456" class="graf graf--li graf-after--li">Install the LLVM package and its dependencies.</li><li name="1fdc" id="1fdc" class="graf graf--li graf-after--li">Verify the installation by running the “llvm-config — version” command in your terminal.</li></ul><p name="e368" id="e368" class="graf graf--p graf-after--li">By following one of these methods, you should be able to install LLVM on your system and start using it for your projects.</p><p name="05cf" id="05cf" class="graf graf--p graf-after--p">The LLVM architecture is designed to be modular and flexible, with different components working together to provide a powerful and customizable compiler infrastructure. The key components of the LLVM architecture are:</p><ol class="postList"><li name="50e1" id="50e1" class="graf graf--li graf-after--p">Front-end: The front-end parses and validates the input code, generates LLVM IR, and feeds it to the rest of the LLVM toolchain. LLVM supports front-ends for many programming languages, including C, C++, Rust, Swift, and Python.</li><li name="0cf9" id="0cf9" class="graf graf--li graf-after--li">LLVM Intermediate Representation (IR): LLVM IR is a high-level, strongly typed, SSA-based intermediate representation used by LLVM to represent program code in a platform-independent way. LLVM IR provides a common language for LLVM’s optimization, and code generation passes.</li><li name="9028" id="9028" class="graf graf--li graf-after--li">LLVM Passes: LLVM passes are individual, customizable optimization and analysis algorithms that operate on LLVM IR. They can perform various tasks, such as dead code elimination, function inlining, and loop optimization. LLVM’s pass system allows users to customize and tune the optimization pipeline to their needs.</li><li name="6979" id="6979" class="graf graf--li graf-after--li">LLVM Target Backends: LLVM target backends generate machine code for a specific hardware architecture. They take LLVM IR as input, perform architecture-specific optimizations, and generate assembly or binary code. LLVM supports many target backends, including x86, ARM, MIPS, PowerPC, and WebAssembly.</li></ol><figure name="885e" id="885e" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*y9YO3sW8pNLZ35HEczPDSA.png" data-width="592" data-height="240" src="https://cdn-images-1.medium.com/max/800/1*y9YO3sW8pNLZ35HEczPDSA.png"></figure><p name="83e9" id="83e9" class="graf graf--p graf-after--figure">To use LLVM to compile code, you need to follow these general steps:</p><ol class="postList"><li name="9411" id="9411" class="graf graf--li graf-after--p">Write your source code in the language of your choice (e.g., C, C++, Rust).</li><li name="aa87" id="aa87" class="graf graf--li graf-after--li">Use the appropriate LLVM front-end for your language to generate LLVM IR.</li><li name="51de" id="51de" class="graf graf--li graf-after--li">Apply optimization passes to the LLVM IR.</li><li name="fccc" id="fccc" class="graf graf--li graf-after--li">Generate machine code for your target architecture using an LLVM target backend.</li></ol><p name="780d" id="780d" class="graf graf--p graf-after--li">Here are some examples of how to use LLVM to compile code in different languages:</p><ol class="postList"><li name="66db" id="66db" class="graf graf--li graf-after--p">Compiling C code with LLVM:</li></ol><p name="e4dd" id="e4dd" class="graf graf--p graf-after--li">To compile C code using LLVM, you can use the clang front-end, which generates LLVM IR from C code:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="typescript" name="93a4" id="93a4" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">clang -<span class="hljs-variable constant_">O3</span> -S -emit-llvm hello.<span class="hljs-property">c</span> -o hello.<span class="hljs-property">ll</span></span></pre><p name="d7b3" id="d7b3" class="graf graf--p graf-after--pre">This command compiles hello.c with optimization level 3 (-O3), generates LLVM IR (-S), and writes it to a file called hello.ll.</p><p name="73d5" id="73d5" class="graf graf--p graf-after--p">You can then apply optimization passes to the generated LLVM IR using the opt tool:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="typescript" name="0914" id="0914" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">opt -<span class="hljs-variable constant_">O3</span> -S hello.<span class="hljs-property">ll</span> -o hello.<span class="hljs-property">opt</span>.<span class="hljs-property">ll</span></span></pre><p name="7ede" id="7ede" class="graf graf--p graf-after--pre">This command applies optimization level 3 to the LLVM IR in hello.ll and writes the optimized output to a file called hello.opt.ll.</p><p name="6787" id="6787" class="graf graf--p graf-after--p">Finally, you can generate machine code for your target architecture using an LLVM target backend such as llc:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="typescript" name="ba28" id="ba28" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">llc -<span class="hljs-variable constant_">O3</span> -filetype=obj hello.<span class="hljs-property">opt</span>.<span class="hljs-property">ll</span> -o hello.<span class="hljs-property">o</span></span></pre><p name="7833" id="7833" class="graf graf--p graf-after--pre">This command generates an object file called hello.o from the optimized LLVM IR in hello.opt.ll using the default target backend (which depends on your system architecture).</p><ol class="postList"><li name="ab3f" id="ab3f" class="graf graf--li graf-after--p">Compiling C++ code with LLVM:</li></ol><p name="0122" id="0122" class="graf graf--p graf-after--li">To compile C++ code using LLVM, you can use the clang++ front-end, which generates LLVM IR from C++ code:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="typescript" name="f3a6" id="f3a6" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">clang++ -<span class="hljs-variable constant_">O3</span> -S -emit-llvm hello.<span class="hljs-property">cpp</span> -o hello.<span class="hljs-property">ll</span></span></pre><p name="ed20" id="ed20" class="graf graf--p graf-after--pre">This command compiles hello.cpp with optimization level 3 (-O3), generates LLVM IR (-S), and writes it to a file called hello.ll.</p><p name="78ca" id="78ca" class="graf graf--p graf-after--p">You can then apply optimization passes to the generated LLVM IR using the opt tool (as in the previous example).</p><p name="42a5" id="42a5" class="graf graf--p graf-after--p">Finally, you can generate machine code for your target architecture using an LLVM target backend such as llc (as in the previous example).</p><ol class="postList"><li name="0f99" id="0f99" class="graf graf--li graf-after--p">Compiling Rust code with LLVM:</li></ol><p name="126d" id="126d" class="graf graf--p graf-after--li">To compile Rust code using LLVM, you can use the rustc compiler, which generates LLVM IR from Rust code:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="lua" name="6477" id="6477" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">rustc -C opt-level=<span class="hljs-number">3</span> <span class="hljs-comment">--emit=llvm-ir hello.rs -o hello.ll</span></span></pre><p name="f645" id="f645" class="graf graf--p graf-after--pre">This command compiles hello.rs with optimization level 3 (-C opt-level=3), generates LLVM IR ( — emit=llvm-ir), and writes it to a file called hello.ll.</p><p name="62e1" id="62e1" class="graf graf--p graf-after--p">You can then apply optimization passes to the generated LLVM IR using the opt tool (as in the previous examples).</p><p name="2560" id="2560" class="graf graf--p graf-after--p">Finally, you can generate machine code for your target architecture using an LLVM target backend such as llc (as in the previous examples).</p><p name="5b95" id="5b95" class="graf graf--p graf-after--p">In addition to the optimizations performed by LLVM’s pass system, you can apply additional compiler optimizations such as loop unrolling, function inlining, and vectorization using compiler flags (e.g., -funroll-loops, -finline-functions, -ftree-vectorize). These optimizations can further improve the performance of your code.</p><p name="c341" id="c341" class="graf graf--p graf-after--p">LLVM provides various tools for debugging code, including the LLDB and GDB debugger.</p><p name="b9bb" id="b9bb" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Writing a simple pass to output all function names present in the code:</strong></p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="cpp" name="48f3" id="48f3" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;llvm/ADT/Statistic.h&quot;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;llvm/IR/Function.h&quot;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;llvm/Pass.h&quot;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;llvm/Support/raw_ostream.h&quot;</span></span><br /><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> llvm;<br /><br /><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEBUG_TYPE <span class="hljs-string">&quot;MyPass&quot;</span></span><br /><br /><span class="hljs-built_in">STATISTIC</span>(HelloCounter, <span class="hljs-string">&quot;It prints the name of our functions present in the code&quot;</span>);<br /><br /><span class="hljs-keyword">namespace</span> {<br /><br /><span class="hljs-comment">// Finding name of the function is our first implementation</span><br /><br />  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyPass</span> : <span class="hljs-keyword">public</span> FunctionPass {<br />    <span class="hljs-type">static</span> <span class="hljs-type">char</span> ID; <span class="hljs-comment">// Pass identification, replacement for typeid</span><br />    <span class="hljs-built_in">MyPass</span>() : <span class="hljs-built_in">FunctionPass</span>(ID) {}<br /><br />    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">runOnFunction</span><span class="hljs-params">(Function &amp;F)</span> <span class="hljs-keyword">override</span> </span>{<br />      ++HelloCounter;<br />      <span class="hljs-built_in">errs</span>() &lt;&lt; <span class="hljs-string">&quot;Function Name: &quot;</span>;<br />      <span class="hljs-built_in">errs</span>().<span class="hljs-built_in">write_escaped</span>(F.<span class="hljs-built_in">getName</span>()) &lt;&lt; HelloCounter &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br />      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br />    }<br />  };<br />}<br /><br /><span class="hljs-type">char</span> MyPass::ID = <span class="hljs-number">0</span>;<br /><span class="hljs-function"><span class="hljs-type">static</span> RegisterPass&lt;MyPass&gt; <span class="hljs-title">X</span><span class="hljs-params">(<span class="hljs-string">&quot;MyPass&quot;</span>, <span class="hljs-string">&quot;My Pass Analyse&quot;</span>,<br /> <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span><br />)</span></span>;<br /><br /></span></pre><figure name="fd4f" id="fd4f" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*nh088ue5WCF8PbTOU86_Iw.png" data-width="1078" data-height="453" src="https://cdn-images-1.medium.com/max/800/1*nh088ue5WCF8PbTOU86_Iw.png"><figcaption class="imageCaption">Output</figcaption></figure><p name="825e" id="825e" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">LLVM Pass for creating CFG for our code:</strong></p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="cpp" name="6660" id="6660" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;llvm/IR/BasicBlock.h&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;llvm/IR/Function.h&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;llvm/Support/raw_ostream.h&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;llvm/IR/User.h&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;llvm/IR/Instructions.h&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;llvm/Pass.h&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;llvm/Analysis/CFG.h&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br /><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> llvm;<br /><br /><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEBUG_TYPE <span class="hljs-string">&quot;CFG&quot;</span></span><br /><br /><span class="hljs-keyword">namespace</span> {<br /> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CFGPass</span> : <span class="hljs-keyword">public</span> FunctionPass {<br />  <span class="hljs-type">static</span> <span class="hljs-type">char</span> ID;<br />  std::error_code error;<br />  std::string str;<br />  <span class="hljs-comment">//StringMap&lt;int&gt;basicblockMap;</span><br />  std::map&lt;BasicBlock*, <span class="hljs-type">int</span>&gt; basicBlockMap;<br />  <span class="hljs-type">int</span> bbCount;  <br />  <span class="hljs-built_in">CFGPass</span>() : <span class="hljs-built_in">FunctionPass</span>(ID){<br />   bbCount = <span class="hljs-number">0</span>;<br />  }<br /><br />  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">runOnFunction</span><span class="hljs-params">(Function &amp;F)</span> <span class="hljs-keyword">override</span> </span>{<br />   <span class="hljs-function">raw_string_ostream <span class="hljs-title">rso</span><span class="hljs-params">(str)</span></span>;<br />   <span class="hljs-function">StringRef <span class="hljs-title">name</span><span class="hljs-params">(F.getName().str() + <span class="hljs-string">&quot;.dot&quot;</span>)</span></span>;<br />   <br />   <span class="hljs-keyword">enum</span> <span class="hljs-title class_">sys</span>::fs::OpenFlags F_None;<br />   <span class="hljs-function">raw_fd_ostream <span class="hljs-title">file</span><span class="hljs-params">(name, error, F_None)</span></span>;<br />   <span class="hljs-comment">//std::ofstream os;</span><br />   <span class="hljs-comment">//os.open(name.str() + &quot;.dot&quot;);</span><br />   <span class="hljs-comment">//if (!os.is_open()){</span><br />   <span class="hljs-comment">// errs() &lt;&lt; &quot;Could not open the &quot; &lt;&lt; name &lt;&lt; &quot;file\n&quot;;</span><br />   <span class="hljs-comment">// return false;</span><br />   <span class="hljs-comment">//}</span><br />   file &lt;&lt; <span class="hljs-string">&quot;digraph \&quot;CFG for&#x27;&quot;</span> + F.<span class="hljs-built_in">getName</span>() + <span class="hljs-string">&quot;\&#x27; function\&quot; {\n&quot;</span>;<br />   <span class="hljs-keyword">for</span> (Function::iterator B_iter = F.<span class="hljs-built_in">begin</span>(); B_iter != F.<span class="hljs-built_in">end</span>(); ++B_iter){<br />    BasicBlock* curBB = &amp;*B_iter;<br />    std::string name = curBB-&gt;<span class="hljs-built_in">getName</span>().<span class="hljs-built_in">str</span>();<br />    <span class="hljs-type">int</span> fromCountNum;<br />    <span class="hljs-type">int</span> toCountNum;<br />    <span class="hljs-keyword">if</span> (basicBlockMap.<span class="hljs-built_in">find</span>(curBB) != basicBlockMap.<span class="hljs-built_in">end</span>())<br />    {<br />     fromCountNum = basicBlockMap[curBB];<br />    }<br />    <span class="hljs-keyword">else</span><br />    {<br />     fromCountNum = bbCount;<br />     basicBlockMap[curBB] = bbCount++;<br />    }<br /><br />    file &lt;&lt; <span class="hljs-string">&quot;\tBB&quot;</span> &lt;&lt; fromCountNum &lt;&lt; <span class="hljs-string">&quot; [shape=record, label=\&quot;{&quot;</span>;<br />    file &lt;&lt; <span class="hljs-string">&quot;BB&quot;</span> &lt;&lt; fromCountNum &lt;&lt; <span class="hljs-string">&quot;:\\l\\l&quot;</span>;<br />    <span class="hljs-keyword">for</span> (BasicBlock::iterator I_iter = curBB-&gt;<span class="hljs-built_in">begin</span>(); I_iter != curBB-&gt;<span class="hljs-built_in">end</span>(); ++I_iter) {<br />     <span class="hljs-comment">//printInstruction(&amp;*I_iter, os);</span><br />     file &lt;&lt; *I_iter &lt;&lt; <span class="hljs-string">&quot;\\l\n&quot;</span>;<br />    }<br />    file &lt;&lt; <span class="hljs-string">&quot;}\&quot;];\n&quot;</span>;<br />    <span class="hljs-keyword">for</span> (BasicBlock *SuccBB : <span class="hljs-built_in">successors</span>(curBB)){<br />     <span class="hljs-keyword">if</span> (basicBlockMap.<span class="hljs-built_in">find</span>(SuccBB) != basicBlockMap.<span class="hljs-built_in">end</span>())<br />     {<br />      toCountNum = basicBlockMap[SuccBB];<br />     }<br />     <span class="hljs-keyword">else</span><br />     {<br />      toCountNum = bbCount;<br />      basicBlockMap[SuccBB] = bbCount++;<br />     }<br /><br />     file &lt;&lt; <span class="hljs-string">&quot;\tBB&quot;</span> &lt;&lt; fromCountNum&lt;&lt; <span class="hljs-string">&quot;-&gt; BB&quot;</span><br />      &lt;&lt; toCountNum &lt;&lt; <span class="hljs-string">&quot;;\n&quot;</span>;<br />    }<br />   }<br />   file &lt;&lt; <span class="hljs-string">&quot;}\n&quot;</span>;<br />   file.<span class="hljs-built_in">close</span>();<br />   <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br />  }<br />  <span class="hljs-comment">//void printInstruction(Instruction *inst, std::ofstream os) {</span><br /><br /> <span class="hljs-comment">//}</span><br /> };<br />}<br /><span class="hljs-type">char</span> CFGPass::ID = <span class="hljs-number">0</span>;<br /><span class="hljs-function"><span class="hljs-type">static</span> RegisterPass&lt;CFGPass&gt; <span class="hljs-title">X</span><span class="hljs-params">(<span class="hljs-string">&quot;CFG&quot;</span>, <span class="hljs-string">&quot;CFG Pass Analyse&quot;</span>,<br /> <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span><br />)</span></span>;</span></pre><figure name="53ff" id="53ff" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*BIDm6dvLygm0yl4JKl3K3Q.png" data-width="733" data-height="992" src="https://cdn-images-1.medium.com/max/800/1*BIDm6dvLygm0yl4JKl3K3Q.png"><figcaption class="imageCaption">CFG of finding prime numbers code in C</figcaption></figure><ol class="postList"><li name="0dea" id="0dea" class="graf graf--li graf-after--figure">Debugging with LLDB:</li></ol><p name="8c6c" id="8c6c" class="graf graf--p graf-after--li">To use LLDB to debug code, you must first generate an LLVM bitcode from your source code using the appropriate LLVM front-end. You can then use LLDB to load the bitcode and debug the resulting program.</p><p name="b4bb" id="b4bb" class="graf graf--p graf-after--p">Here’s an example of how to use LLDB to debug a C program:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="r" name="4156" id="4156" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">clang <span class="hljs-operator">-</span>g <span class="hljs-operator">-</span><span class="hljs-built_in">c</span> <span class="hljs-operator">-</span>emit<span class="hljs-operator">-</span>llvm hello.c <span class="hljs-operator">-</span>o hello.bc<br />lldb hello.bc</span></pre><p name="b687" id="b687" class="graf graf--p graf-after--pre">his command compiles hello.c with debugging information (-g), generates LLVM bitcode (-c -emit-llvm), and writes it to a file called hello.bc. It then launches LLDB and loads the bitcode file for debugging.</p><p name="c8e9" id="c8e9" class="graf graf--p graf-after--p">Once LLDB is running, you can use various commands to debug your program, such as:</p><ul class="postList"><li name="d4b9" id="d4b9" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">run</code>: Start running the program.</li><li name="3fa3" id="3fa3" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">breakpoint set</code>: Set a breakpoint at a particular line of code.</li><li name="c96a" id="c96a" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">step</code>: Step into the next statement.</li><li name="2243" id="2243" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">next</code>: Step over the next statement.</li><li name="06f4" id="06f4" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">print</code>: Print the value of a variable.</li></ul><ol class="postList"><li name="ad2b" id="ad2b" class="graf graf--li graf-after--li">Debugging with GDB:</li></ol><p name="55ec" id="55ec" class="graf graf--p graf-after--li">To use GDB to debug code generated by LLVM, you need to generate machine code from the LLVM bitcode using an LLVM target backend such as llc. You can then use GDB to load the machine code and debug the resulting program.</p><p name="c83d" id="c83d" class="graf graf--p graf-after--p">Here’s an example of how to use GDB to debug a C program:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="r" name="de43" id="de43" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">clang <span class="hljs-operator">-</span>g <span class="hljs-operator">-</span><span class="hljs-built_in">c</span> <span class="hljs-operator">-</span>emit<span class="hljs-operator">-</span>llvm hello.c <span class="hljs-operator">-</span>o hello.bc<br />llc hello.bc <span class="hljs-operator">-</span>o hello.s<br />clang <span class="hljs-operator">-</span>g hello.s <span class="hljs-operator">-</span>o hello<br />gdb hello</span></pre><p name="1b46" id="1b46" class="graf graf--p graf-after--pre">This command compiles hello.c with debugging information (-g), generates LLVM bitcode (-c -emit-llvm), writes it to a file called hello.bc, generates machine code (-o hello.s) using the default target backend, compiles the machine code (-g hello.s -o hello), and launches GDB to debug the resulting executable.</p><p name="9bc3" id="9bc3" class="graf graf--p graf-after--p">Once GDB is running, you can use various commands to debug your program, such as:</p><ul class="postList"><li name="c505" id="c505" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">run</code>: Start running the program.</li><li name="419b" id="419b" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">break</code>: Set a breakpoint at a particular line of code.</li><li name="43ae" id="43ae" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">step</code>: Step into the next statement.</li><li name="145d" id="145d" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">next</code>: Step over the next statement.</li><li name="f74f" id="f74f" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">print</code>: Print the value of a variable.</li></ul><p name="384a" id="384a" class="graf graf--p graf-after--li">LLVM provides powerful tools for debugging code, including LLDB and GDB. These tools allow you to debug programs generated by LLVM using various debugging techniques such as breakpoints, stepping, and printing variable values.</p><p name="6b81" id="6b81" class="graf graf--p graf-after--p">LLVM has been used in a wide range of projects across various domains. Here are some of the popular projects that use LLVM:</p><ol class="postList"><li name="a05b" id="a05b" class="graf graf--li graf-after--p">Clang: Clang is a C/C++/Objective-C compiler front-end for LLVM. It is designed to provide better diagnostics and faster compilation times than the GNU Compiler Collection (GCC) and supports many C++ features not supported by GCC.</li><li name="7a8d" id="7a8d" class="graf graf--li graf-after--li">Swift: Swift is a programming language developed by Apple for macOS, iOS, watchOS, and tvOS development. Swift uses LLVM as its compiler infrastructure and leverages LLVM’s optimization capabilities to generate fast and efficient code.</li><li name="2159" id="2159" class="graf graf--li graf-after--li">Rust: Rust is a systems programming language focusing on safety, speed, and concurrency. Rust uses LLVM as its compiler infrastructure and takes advantage of LLVM’s optimization capabilities to generate fast and efficient code.</li><li name="d609" id="d609" class="graf graf--li graf-after--li">Mesa 3D: Mesa 3D is an open-source implementation of OpenGL, Vulkan, and other graphics API specifications. Mesa 3D uses LLVM as a shader compiler and takes advantage of LLVM’s optimization capabilities to generate fast and efficient shader code.</li><li name="261e" id="261e" class="graf graf--li graf-after--li">FreeBSD: FreeBSD is a free and open-source Unix-like operating system that runs on a wide range of hardware platforms. FreeBSD uses LLVM as its system compiler and leverages LLVM’s optimization capabilities to generate fast and efficient code.</li><li name="aaff" id="aaff" class="graf graf--li graf-after--li">Julia: Julia is a high-level, high-performance programming language designed for numerical and scientific computing. Julia uses LLVM as its compiler infrastructure and leverages LLVM’s optimization capabilities to generate fast and efficient code.</li></ol><p name="2fd8" id="2fd8" class="graf graf--p graf-after--li graf--trailing">LLVM is a widely-used infrastructure for compilers and has been used in a variety of projects across various domains, including programming languages, graphics APIs, and operating systems. These projects leverage LLVM’s optimization capabilities to generate fast and efficient code.</p></div></div></section><section name="c11e" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="ed6d" id="ed6d" class="graf graf--p graf--leading">In this article, we’ve explored LLVM, a popular compiler infrastructure used in software development. We started by discussing LLVM&#39;s purpose in the software development world. We then covered various topics such as installing LLVM, LLVM architecture, compiling with LLVM, and debugging with LLVM. We also mentioned some popular projects that use LLVM and how they leverage LLVM’s optimization capabilities to generate fast and efficient code.</p><p name="0ad6" id="0ad6" class="graf graf--p graf-after--p">Using LLVM, developers can use its optimization capabilities to generate high-quality, optimized code. LLVM also provides a modular architecture that makes adding support for new languages, targets, and optimization passes easy.</p><p name="d07d" id="d07d" class="graf graf--p graf-after--p">In conclusion, LLVM is a powerful and versatile infrastructure that offers many benefits to developers. It is used in various projects across various domains and is valuable in your software development toolkit. We encourage readers to explore LLVM further and experiment with its capabilities to see how it can benefit their software development projects.</p><p name="2f7e" id="2f7e" class="graf graf--p graf-after--p graf--trailing">For further information, you can check my GitHub repo over LLVM Passes by clicking on this link: <a href="https://github.com/vishalcseiitg/LLVM-Passes.git" data-href="https://github.com/vishalcseiitg/LLVM-Passes.git" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">LLVM_Passes</a></p></div></div></section><section name="2c52" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="67de" id="67de" class="graf graf--p graf--leading">To use a custom pass with LLVM, you need to add the pass code to the LLVM source tree and then build LLVM with the new pass. Here are the steps to add and build a custom pass in LLVM:</p><ol class="postList"><li name="f875" id="f875" class="graf graf--li graf-after--p">Create a new folder named MyPass in llvm-project/llvm/lib/Transforms/ to hold your pass code. Inside this folder, create a file named MyPass.cpp, which will contain your pass implementation. You should also include a file named MyPass.exports (which can be left empty) and a CMakeLists.txt file.</li><li name="6c99" id="6c99" class="graf graf--li graf-after--li">In the CMakeLists.txt file, add the following code:</li></ol><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="bash" name="d290" id="d290" class="graf graf--pre graf-after--li graf--preV2"><span class="pre--content"><span class="hljs-comment"># If we don&#x27;t need RTTI or EH, there&#x27;s no reason to export anything</span><br /><span class="hljs-comment"># from the hello plugin.</span><br /><span class="hljs-keyword">if</span>( NOT LLVM_REQUIRES_RTTI )<br />  <span class="hljs-keyword">if</span>( NOT LLVM_REQUIRES_EH )<br />    <span class="hljs-built_in">set</span>(LLVM_EXPORTED_SYMBOL_FILE <span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span>/MyPass.exports)<br />  endif()<br />endif()<br /><br /><span class="hljs-keyword">if</span>(WIN32 OR CYGWIN)<br />  <span class="hljs-built_in">set</span>(LLVM_LINK_COMPONENTS Core Support)<br />endif()<br /><br />add_llvm_library( MyPass MODULE BUILDTREE_ONLY<br />  MyPass.cpp<br /><br />  DEPENDS<br />  intrinsics_gen<br />  PLUGIN_TOOL<br />  opt<br />)</span></pre><p name="b206" id="b206" class="graf graf--p graf-after--pre">This code sets the exported symbol file for your pass, adds the necessary LLVM components, and creates a new LLVM module named MyPass from your pass implementation file.</p><ol class="postList"><li name="6afa" id="6afa" class="graf graf--li graf-after--p">In the file llvm-project/llvm/lib/Transforms/CMakeLists.txt, append the line <code class="markup--code markup--li-code">add_subdirectory(MyPass)</code> at the end. This tells LLVM to include your new pass in the build.</li><li name="f25b" id="f25b" class="graf graf--li graf-after--li">In the <code class="markup--code markup--li-code">llvm-project/llvm/lib/Transforms/CMakeLists.txt</code> file, add the line <code class="markup--code markup--li-code">add_subdirectory(MyPass)</code> at the end.</li><li name="e028" id="e028" class="graf graf--li graf-after--li">Go to the build directory and run the <code class="markup--code markup--li-code">make</code> command (you can use <code class="markup--code markup--li-code">-j 8</code> to speed up the process).</li><li name="1b77" id="1b77" class="graf graf--li graf-after--li">Create an LLVM IR file from a C program file using the following command: <code class="markup--code markup--li-code">clang -S -emit-llvm file_name.c</code>. This will produce a file named <code class="markup--code markup--li-code">file_name.ll</code>.</li><li name="ef5a" id="ef5a" class="graf graf--li graf-after--li">Run your pass on the LLVM IR file using the command:</li></ol><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="lua" name="2d84" id="2d84" class="graf graf--pre graf-after--li graf--preV2"><span class="pre--content">&lt;<span class="hljs-built_in">path</span>-to-llvm&gt;/llvm-project/build/bin/opt -enable-new-pm=<span class="hljs-number">0</span> -disable-<span class="hljs-built_in">output</span> -<span class="hljs-built_in">load</span> LLVMMyPass.so file_name.ll <span class="hljs-comment">--mypass</span></span></pre><ol class="postList"><li name="8684" id="8684" class="graf graf--li graf-after--pre graf--trailing">Here, <code class="markup--code markup--li-code">--mypass</code> is the name with which you registered the pass in <code class="markup--code markup--li-code">MyPass.cpp</code>.</li></ol></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@the_daft_introvert" class="p-author h-card">Vishal Sharma</a> on <a href="https://medium.com/p/4216c60f51c5"><time class="dt-published" datetime="2023-03-07T13:59:58.031Z">March 7, 2023</time></a>.</p><p><a href="https://medium.com/@the_daft_introvert/unleashing-the-power-of-llvm-a-comprehensive-guide-to-getting-started-with-low-level-virtual-4216c60f51c5" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on April 2, 2023.</p></footer></article></body></html>