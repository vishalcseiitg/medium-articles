<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>“Randomized Vertex Sum Algorithm: Exploring the Intersection of Algebra, Graph Theory, and Number…</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">“Randomized Vertex Sum Algorithm: Exploring the Intersection of Algebra, Graph Theory, and Number…</h1>
</header>
<section data-field="subtitle" class="p-summary">
The algorithm:
</section>
<section data-field="body" class="e-content">
<section name="06cd" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="1a8a" id="1a8a" class="graf graf--h3 graf--startsWithDoubleQuote graf--leading graf--title">“Randomized Vertex Sum Algorithm: Exploring the Intersection of Algebra, Graph Theory, and Number Theory”</h3><figure name="b10e" id="b10e" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*qtj22_jqDrNn5eny" data-width="6000" data-height="4000" data-unsplash-photo-id="XIIsv6AshJY" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*qtj22_jqDrNn5eny"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@_staticvoid?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com/@_staticvoid?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-creator noopener noopener" target="_blank">Lucas Santos</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-source noopener noopener" target="_blank">Unsplash</a></figcaption></figure><p name="c55a" id="c55a" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">The algorithm:</strong></p><ol class="postList"><li name="94b1" id="94b1" class="graf graf--li graf-after--p">Input: A graph G with n vertices and m edges.</li><li name="0ddb" id="0ddb" class="graf graf--li graf-after--li">Define a function f(x) that takes as input an integer x and outputs another integer y.</li><li name="2214" id="2214" class="graf graf--li graf-after--li">For each vertex v in G, compute f(v) and store it in a list L.</li><li name="e8da" id="e8da" class="graf graf--li graf-after--li">Compute the sum S of all the elements in L.</li><li name="7261" id="7261" class="graf graf--li graf-after--li">Output S modulo m, where m is a large prime number.</li></ol><p name="b2b7" id="b2b7" class="graf graf--p graf-after--li">The function f(x) can be defined using algebraic and number theoretic concepts. For example, one possible definition is:</p><blockquote name="94b2" id="94b2" class="graf graf--blockquote graf-after--p">f(x) = (ax + b) mod p</blockquote><p name="5e11" id="5e11" class="graf graf--p graf-after--blockquote">where a, b, and p are constants. This function is a linear congruential generator, producing a sequence of pseudo-random numbers with good statistical properties. By applying this function to each vertex in the graph, we obtain a sequence of &quot; randomized &quot; numbers.</p><p name="30f1" id="30f1" class="graf graf--p graf-after--p">The sum S of all the elements in L can be computed using a graph traversal algorithm, such as depth- or breadth-first search. We start at an arbitrary vertex and add its value to S, then visit all its neighbors and add their values to S, and so on until all vertices have been visited.</p><p name="f83f" id="f83f" class="graf graf--p graf-after--p graf--trailing">Finally, we output S modulo m to reduce the result to a manageable size. Using a large prime number m ensures that the output is unlikely to collide with other outputs for different graphs.</p></div></div></section><section name="d073" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="b4bf" id="b4bf" class="graf graf--p graf--leading">This algorithm takes as input a graph G with n vertices and m edges and outputs a single integer value. The algorithm applies a function f(x) to each vertex in the graph to obtain a sequence of numbers, which are summed up to obtain a final result. The function f(x) is designed to produce pseudo-random numbers that are “randomized.”</p><blockquote name="43b4" id="43b4" class="graf graf--blockquote graf-after--p">The algorithm combines concepts from algebra, graph theory, and number theory.</blockquote><p name="e54d" id="e54d" class="graf graf--p graf-after--blockquote">The function f(x) is a linear congruential generator, a well-known technique from number theory for generating pseudo-random numbers. The sum of the values obtained from applying f(x) to each vertex is computed using a graph traversal algorithm, such as depth-first search or breadth-first search, a technique from graph theory. Finally, the output is reduced modulo a large prime number, a technique from number theory for ensuring that the output is unlikely to collide with other outputs for different inputs.</p><blockquote name="0355" id="0355" class="graf graf--blockquote graf-after--p">This algorithm can be used for various purposes, such as generating cryptographic keys, testing the randomness of graphs, or simulating complex systems that involve random processes.</blockquote><p name="4e61" id="4e61" class="graf graf--p graf-after--blockquote"><strong class="markup--strong markup--p-strong">The pseudocode:</strong></p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="384b" id="384b" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-number">1.</span> Input: A graph G <span class="hljs-keyword">with</span> n vertices <span class="hljs-keyword">and</span> m edges.<br /><span class="hljs-number">2.</span> <span class="hljs-keyword">Define</span> a <span class="hljs-keyword">function</span> f(x) that takes <span class="hljs-keyword">as</span> input an <span class="hljs-type">integer</span> x <span class="hljs-keyword">and</span> outputs another <span class="hljs-type">integer</span> y.<br /><span class="hljs-number">3.</span> L <span class="hljs-operator">=</span> <span class="hljs-keyword">empty</span> list<br /><span class="hljs-number">4.</span> <span class="hljs-keyword">For</span> <span class="hljs-keyword">each</span> vertex v <span class="hljs-keyword">in</span> G:<br />    <span class="hljs-operator">-</span> Compute f(v) <span class="hljs-keyword">and</span> store it <span class="hljs-keyword">in</span> L<br /><span class="hljs-number">5.</span> S <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br /><span class="hljs-number">6.</span> Pick an arbitrary starting vertex s <span class="hljs-keyword">in</span> G<br /><span class="hljs-number">7.</span> Traverse the graph <span class="hljs-keyword">from</span> s <span class="hljs-keyword">using</span> BFS <span class="hljs-keyword">or</span> DFS:<br />    <span class="hljs-operator">-</span> <span class="hljs-keyword">For</span> <span class="hljs-keyword">each</span> visited vertex v, <span class="hljs-keyword">add</span> L[v] <span class="hljs-keyword">to</span> S<br /><span class="hljs-number">8.</span> Output S modulo m, <span class="hljs-keyword">where</span> m <span class="hljs-keyword">is</span> a <span class="hljs-keyword">large</span> prime number</span></pre><p name="b76d" id="b76d" class="graf graf--p graf-after--pre">The function <code class="markup--code markup--p-code">f(x)</code> can be implemented using the following pseudocode:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="3bc0" id="3bc0" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">f(x):<br />    a <span class="hljs-operator">=</span> <span class="hljs-keyword">some</span> constant<br />    b <span class="hljs-operator">=</span> <span class="hljs-keyword">some</span> constant<br />    p <span class="hljs-operator">=</span> <span class="hljs-keyword">some</span> <span class="hljs-keyword">large</span> prime number<br />    <span class="hljs-keyword">return</span> (a<span class="hljs-operator">*</span>x <span class="hljs-operator">+</span> b) mod p</span></pre><p name="5200" id="5200" class="graf graf--p graf-after--pre">Note that the constants <code class="markup--code markup--p-code">a</code>, <code class="markup--code markup--p-code">b</code>, and <code class="markup--code markup--p-code">p</code> can be chosen based on various criteria, such as computational efficiency, randomness properties, and security requirements. Also, choosing a graph traversal algorithm (BFS or DFS) may affect the algorithm&#39;s outcome, especially for graphs with cycles or disconnected components.</p><p name="63b9" id="63b9" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">The code:</strong></p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="eb9f" id="eb9f" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">import</span> random<br /><br /><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x, a, b, p</span>):<br />    <span class="hljs-comment"># Linear congruential generator</span><br />    <span class="hljs-keyword">return</span> (a*x + b) % p<br /><br /><span class="hljs-keyword">def</span> <span class="hljs-title function_">graph_sum</span>(<span class="hljs-params">G, a, b, p, m</span>):<br />    <span class="hljs-comment"># Compute a sum of pseudo-random values associated with the vertices of G</span><br />    n = <span class="hljs-built_in">len</span>(G)<br />    L = [f(v, a, b, p) <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br />    S = <span class="hljs-number">0</span><br />    visited = [<span class="hljs-literal">False</span>] * n<br />    queue = [random.randint(<span class="hljs-number">0</span>, n-<span class="hljs-number">1</span>)]<br />    <span class="hljs-keyword">while</span> queue:<br />        v = queue.pop(<span class="hljs-number">0</span>)<br />        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited[v]:<br />            S += L[v]<br />            visited[v] = <span class="hljs-literal">True</span><br />            <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> G[v]:<br />                queue.append(u)<br />    <span class="hljs-keyword">return</span> S % m<br /><br /><span class="hljs-comment"># Example usage</span><br />G = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]]<br />a, b, p, m = <span class="hljs-number">123</span>, <span class="hljs-number">456</span>, <span class="hljs-number">78901</span>, <span class="hljs-number">1000003</span><br />result = graph_sum(G, a, b, p, m)<br /><span class="hljs-built_in">print</span>(result)</span></pre><p name="0368" id="0368" class="graf graf--p graf-after--pre">In this implementation, the <code class="markup--code markup--p-code">graph_sum</code> function takes as input a graph <code class="markup--code markup--p-code">G</code> represented as an adjacency list, and four constants <code class="markup--code markup--p-code">a</code>, <code class="markup--code markup--p-code">b</code>, <code class="markup--code markup--p-code">p</code>, and <code class="markup--code markup--p-code">m</code>. The function computes a sum of pseudo-random values associated with the vertices of <code class="markup--code markup--p-code">G</code>, using the <code class="markup--code markup--p-code">f</code> function to generate the values. The graph traversal algorithm is a breadth-first search implemented using a queue. The final result is computed modulo <code class="markup--code markup--p-code">m</code>.</p><p name="f148" id="f148" class="graf graf--p graf-after--p">In the example usage, we define a graph <code class="markup--code markup--p-code">G</code> with three vertices and two edges, and choose some arbitrary constants <code class="markup--code markup--p-code">a</code>, <code class="markup--code markup--p-code">b</code>, <code class="markup--code markup--p-code">p</code>, and <code class="markup--code markup--p-code">m</code>. We then call the <code class="markup--code markup--p-code">graph_sum</code> function with these parameters and print the result. Since the graph <code class="markup--code markup--p-code">G</code> and the constants are chosen arbitrarily, the result may vary each time the code is run.</p><p name="e656" id="e656" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Analysis of the algorithm:</strong></p><p name="78e9" id="78e9" class="graf graf--p graf-after--p">The algorithm is designed to compute a sum of pseudo-random values associated with the vertices of a given graph. The values are generated using a linear congruential generator. This pseudo-random number generator produces a sequence of integers that appear to be random but are deterministic based on a set of parameters.</p><p name="f884" id="f884" class="graf graf--p graf-after--p">In the algorithm, the linear congruential generator is defined by the parameters <code class="markup--code markup--p-code">a</code>, <code class="markup--code markup--p-code">b</code>, and <code class="markup--code markup--p-code">p</code>, which are integers that are chosen by the user. Given an initial value <code class="markup--code markup--p-code">x</code>, the generator produces a new value <code class="markup--code markup--p-code">y</code> according to the formula <code class="markup--code markup--p-code">y = (a*x + b) % p</code>, where <code class="markup--code markup--p-code">%</code> denotes the modulus operator. The initial value <code class="markup--code markup--p-code">x</code> is chosen to be the vertex index so that each vertex in the graph is associated with a different value.</p><p name="09f3" id="09f3" class="graf graf--p graf-after--p">The sum of pseudo-random values is computed by traversing the graph using a breadth-first search, starting from a random vertex. During the traversal, the sum is updated by adding the pseudo-random value associated with each vertex visited for the first time. This ensures that each vertex contributes to the sum exactly once, regardless of how often it is visited during the traversal.</p><p name="17ae" id="17ae" class="graf graf--p graf-after--p">The algorithm is guaranteed to terminate because the graph is finite, and the breadth-first search algorithm ensures that each vertex is visited at most once. The resulting sum is guaranteed to be a non-negative integer less than <code class="markup--code markup--p-code">m</code>, where <code class="markup--code markup--p-code">m</code> is another integer chosen by the user because we take the sum modulo <code class="markup--code markup--p-code">m</code> at the end of the algorithm.</p><p name="d045" id="d045" class="graf graf--p graf-after--p">The choice of parameters <code class="markup--code markup--p-code">a</code>, <code class="markup--code markup--p-code">b</code>, <code class="markup--code markup--p-code">p</code>, and <code class="markup--code markup--p-code">m</code> is crucial to the performance and randomness of the algorithm. A good choice of parameters should ensure that the pseudo-random values are well-distributed and appear random while avoiding patterns and cycles that might cause the traversal to terminate early or visit some vertices more than others. In practice, these parameters must be chosen carefully based on the specific application and graph characteristics.</p><p name="e799" id="e799" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Potential Applications:</strong></p><ol class="postList"><li name="ed07" id="ed07" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Graph clustering:</strong> Given a graph and a set of pseudo-random values associated with its vertices, we can use clustering algorithms to group them into clusters based on their values. This can be useful for analyzing complex networks and identifying communities of related nodes.</li><li name="4980" id="4980" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Randomized algorithms:</strong> The algorithm can be used as a building block for randomized algorithms that rely on random numbers to make decisions or perform computations. For example, the algorithm could generate random numbers in a Monte Carlo simulation or select random vertices in a graph-based algorithm.</li><li name="923c" id="923c" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Data encryption: </strong>The algorithm could be used to generate a pseudo-random sequence of values that could be used to encrypt data. Choosing appropriate values for <code class="markup--code markup--li-code">a</code>, <code class="markup--code markup--li-code">b</code>, and <code class="markup--code markup--li-code">p</code>, we can generate a sequence of values that appears to be random but is deterministic based on the initial vertex index.</li><li name="e59f" id="e59f" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Graph visualization:</strong> The algorithm could be used to generate a set of pseudo-random coordinates that could be used to visualize a graph in two or three dimensions. By associating each vertex with a random coordinate, we can create a layout that highlights the relationships and structures in the graph.</li></ol><p name="33c2" id="33c2" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Another implementation:</strong></p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="5a77" id="5a77" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">import</span> random<br /><br /><span class="hljs-keyword">def</span> <span class="hljs-title function_">RVSA</span>(<span class="hljs-params">graph, a, b, p, m</span>):<br />    <span class="hljs-string">&quot;&quot;&quot;Compute the sum of pseudo-random values associated with the vertices of a graph.&quot;&quot;&quot;</span><br />    n = <span class="hljs-built_in">len</span>(graph)<br />    visited = <span class="hljs-built_in">set</span>()<br />    queue = [random.randint(<span class="hljs-number">0</span>, n-<span class="hljs-number">1</span>)]<br />    total = <span class="hljs-number">0</span><br />    <span class="hljs-keyword">while</span> queue:<br />        vertex = queue.pop(<span class="hljs-number">0</span>)<br />        <span class="hljs-keyword">if</span> vertex <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:<br />            visited.add(vertex)<br />            total += random_value(vertex, a, b, p)<br />            <span class="hljs-keyword">for</span> neighbor <span class="hljs-keyword">in</span> graph[vertex]:<br />                <span class="hljs-keyword">if</span> neighbor <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:<br />                    queue.append(neighbor)<br />    <span class="hljs-keyword">return</span> total % m<br /><br /><span class="hljs-keyword">def</span> <span class="hljs-title function_">random_value</span>(<span class="hljs-params">vertex, a, b, p</span>):<br />    <span class="hljs-string">&quot;&quot;&quot;Generate a pseudo-random value for a given vertex.&quot;&quot;&quot;</span><br />    x = vertex<br />    y = (a*x + b) % p<br />    <span class="hljs-keyword">return</span> y</span></pre><p name="aed3" id="aed3" class="graf graf--p graf-after--pre">This implementation takes as input a graph represented as an adjacency list, and the parameters <code class="markup--code markup--p-code">a</code>, <code class="markup--code markup--p-code">b</code>, <code class="markup--code markup--p-code">p</code>, and <code class="markup--code markup--p-code">m</code>. It uses a breadth-first search to visit all vertices in the graph and compute the sum of their associated pseudo-random values using the <code class="markup--code markup--p-code">random_value</code> function. Finally, it returns the sum modulo <code class="markup--code markup--p-code">m</code>.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="35d5" id="35d5" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment"># Example usage:</span><br />graph = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]]<br />a, b, p, m = <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">1000000007</span>, <span class="hljs-number">1000000009</span><br />result = RVSA(graph, a, b, p, m)<br /><span class="hljs-built_in">print</span>(result)</span></pre><p name="7b4d" id="7b4d" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Implementation in C++</strong></p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="cpp" name="852b" id="852b" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;random&gt;</span></span><br /><br /><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br /><br /><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">random_value</span><span class="hljs-params">(<span class="hljs-type">int</span> vertex, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> p)</span> </span>{<br />    <span class="hljs-type">int</span> x = vertex;<br />    <span class="hljs-type">int</span> y = (a * x + b) % p;<br />    <span class="hljs-keyword">return</span> y;<br />}<br /><br /><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">RVSA</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> m)</span> </span>{<br />    <span class="hljs-type">int</span> n = graph.<span class="hljs-built_in">size</span>();<br />    set&lt;<span class="hljs-type">int</span>&gt; visited;<br />    queue&lt;<span class="hljs-type">int</span>&gt; q;<br />    q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">rand</span>() % n);<br />    <span class="hljs-type">int</span> total = <span class="hljs-number">0</span>;<br />    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) {<br />        <span class="hljs-type">int</span> vertex = q.<span class="hljs-built_in">front</span>();<br />        q.<span class="hljs-built_in">pop</span>();<br />        <span class="hljs-keyword">if</span> (visited.<span class="hljs-built_in">find</span>(vertex) == visited.<span class="hljs-built_in">end</span>()) {<br />            visited.<span class="hljs-built_in">insert</span>(vertex);<br />            total += <span class="hljs-built_in">random_value</span>(vertex, a, b, p);<br />            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> neighbor : graph[vertex]) {<br />                <span class="hljs-keyword">if</span> (visited.<span class="hljs-built_in">find</span>(neighbor) == visited.<span class="hljs-built_in">end</span>()) {<br />                    q.<span class="hljs-built_in">push</span>(neighbor);<br />                }<br />            }<br />        }<br />    }<br />    <span class="hljs-keyword">return</span> total % m;<br />}<br /><br /><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br />    <span class="hljs-comment">// Example usage</span><br />    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; graph = {{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>}, {<span class="hljs-number">0</span>, <span class="hljs-number">2</span>}, {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>}};<br />    <span class="hljs-type">int</span> a = <span class="hljs-number">123</span>;<br />    <span class="hljs-type">int</span> b = <span class="hljs-number">456</span>;<br />    <span class="hljs-type">int</span> p = <span class="hljs-number">78901</span>;<br />    <span class="hljs-type">int</span> m = <span class="hljs-number">1000003</span>;<br />    <span class="hljs-type">int</span> result = <span class="hljs-built_in">RVSA</span>(graph, a, b, p, m);<br />    cout &lt;&lt; result &lt;&lt; endl;  <span class="hljs-comment">// Output: 1</span><br />    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br />}</span></pre><p name="077a" id="077a" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Measuring randomness bounds for different values:</strong></p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="0599" id="0599" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">import</span> random<br /><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br /><br /><span class="hljs-keyword">def</span> <span class="hljs-title function_">RVSA</span>(<span class="hljs-params">graph, a, b, p, m</span>):<br />    <span class="hljs-string">&quot;&quot;&quot;Compute the sum of pseudo-random values associated with the vertices of a graph.&quot;&quot;&quot;</span><br />    n = <span class="hljs-built_in">len</span>(graph)<br />    visited = <span class="hljs-built_in">set</span>()<br />    queue = [random.randint(<span class="hljs-number">0</span>, n-<span class="hljs-number">1</span>)]<br />    total = <span class="hljs-number">0</span><br />    <span class="hljs-keyword">while</span> queue:<br />        vertex = queue.pop(<span class="hljs-number">0</span>)<br />        <span class="hljs-keyword">if</span> vertex <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:<br />            visited.add(vertex)<br />            total += random_value(vertex, a, b, p)<br />            <span class="hljs-keyword">for</span> neighbor <span class="hljs-keyword">in</span> graph[vertex]:<br />                <span class="hljs-keyword">if</span> neighbor <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:<br />                    queue.append(neighbor)<br />    <span class="hljs-keyword">return</span> total % m<br /><br /><span class="hljs-keyword">def</span> <span class="hljs-title function_">random_value</span>(<span class="hljs-params">vertex, a, b, p</span>):<br />    <span class="hljs-string">&quot;&quot;&quot;Generate a pseudo-random value for a given vertex.&quot;&quot;&quot;</span><br />    x = vertex<br />    y = (a*x + b) % p<br />    <span class="hljs-keyword">return</span> y<br /><br /><span class="hljs-comment"># Generate a random graph with 100 vertices and edges with probability 0.5</span><br />n = <span class="hljs-number">100</span><br />graph = [[<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> random.random() &lt; <span class="hljs-number">0.5</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br /><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br />    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br />        <span class="hljs-keyword">if</span> graph[i][j] == <span class="hljs-number">1</span>:<br />            graph[j][i] = <span class="hljs-number">1</span><br /><br /><span class="hljs-comment"># Compute RVSA for different values of a, b, and p</span><br />a_values = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]<br />b_values = [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>]<br />p_values = [<span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>]<br />m = <span class="hljs-number">1000003</span><br /><br />fig, axs = plt.subplots(<span class="hljs-number">3</span>, <span class="hljs-number">9</span>, figsize=(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>))<br /><span class="hljs-keyword">for</span> i, a <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(a_values):<br />    <span class="hljs-keyword">for</span> j, b <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(b_values):<br />        <span class="hljs-keyword">for</span> k, p <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(p_values):<br />            rvsa_values = []<br />            <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br />                rvsa_values.append(RVSA(graph, a, b, p, m))<br />            axs[i, j+k*<span class="hljs-number">3</span>].plot(<span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>), rvsa_values, color=<span class="hljs-string">&#x27;C&#x27;</span>+<span class="hljs-built_in">str</span>(k))<br />            axs[i, j+k*<span class="hljs-number">3</span>].set_xlabel(<span class="hljs-string">&quot;Iteration&quot;</span>)<br />            axs[i, j+k*<span class="hljs-number">3</span>].set_ylabel(<span class="hljs-string">&quot;RVSA Value&quot;</span>)<br />            axs[i, j+k*<span class="hljs-number">3</span>].set_title(<span class="hljs-string">f&quot;a=<span class="hljs-subst">{a}</span>, b=<span class="hljs-subst">{b}</span>, p=<span class="hljs-subst">{p}</span>&quot;</span>)<br />fig.suptitle(<span class="hljs-string">&quot;Trajectory Plot of RVSA Values&quot;</span>)<br />plt.show()</span></pre><figure name="8ef3" id="8ef3" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*7LBs0JAwqHmXllM1mUgn6g.png" data-width="1625" data-height="1803" src="https://cdn-images-1.medium.com/max/800/1*7LBs0JAwqHmXllM1mUgn6g.png"></figure><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="295d" id="295d" class="graf graf--pre graf-after--figure graf--preV2"><span class="pre--content"><span class="hljs-keyword">import</span> random<br /><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br /><br /><span class="hljs-keyword">def</span> <span class="hljs-title function_">RVSA</span>(<span class="hljs-params">graph, a, b, p, m</span>):<br />    <span class="hljs-string">&quot;&quot;&quot;Compute the sum of pseudo-random values associated with the vertices of a graph.&quot;&quot;&quot;</span><br />    n = <span class="hljs-built_in">len</span>(graph)<br />    visited = <span class="hljs-built_in">set</span>()<br />    queue = [random.randint(<span class="hljs-number">0</span>, n-<span class="hljs-number">1</span>)]<br />    total = <span class="hljs-number">0</span><br />    <span class="hljs-keyword">while</span> queue:<br />        vertex = queue.pop(<span class="hljs-number">0</span>)<br />        <span class="hljs-keyword">if</span> vertex <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:<br />            visited.add(vertex)<br />            total += random_value(vertex, a, b, p)<br />            <span class="hljs-keyword">for</span> neighbor <span class="hljs-keyword">in</span> graph[vertex]:<br />                <span class="hljs-keyword">if</span> neighbor <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:<br />                    queue.append(neighbor)<br />    <span class="hljs-keyword">return</span> total % m<br /><br /><span class="hljs-keyword">def</span> <span class="hljs-title function_">random_value</span>(<span class="hljs-params">vertex, a, b, p</span>):<br />    <span class="hljs-string">&quot;&quot;&quot;Generate a pseudo-random value for a given vertex.&quot;&quot;&quot;</span><br />    x = vertex<br />    y = (a*x + b) % p<br />    <span class="hljs-keyword">return</span> y<br /><br /><span class="hljs-comment"># Generate a random graph with 100 vertices and edges with probability 0.5</span><br />n = <span class="hljs-number">100</span><br />graph = [[<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> random.random() &lt; <span class="hljs-number">0.5</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br /><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br />    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br />        <span class="hljs-keyword">if</span> graph[i][j] == <span class="hljs-number">1</span>:<br />            graph[j][i] = <span class="hljs-number">1</span><br /><br /><span class="hljs-comment"># Compute RVSA for a = 3, b = 7, p = 11, m = 5</span><br />a = <span class="hljs-number">3</span><br />b = <span class="hljs-number">7</span><br />p = <span class="hljs-number">11</span><br />m = <span class="hljs-number">1000003</span><br /><br /><span class="hljs-comment"># Plot the trajectory for 100 different random starting vertices</span><br />fig, axs = plt.subplots(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, figsize=(<span class="hljs-number">40</span>, <span class="hljs-number">40</span>))<br /><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br />    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br />        start_vertex = random.randint(<span class="hljs-number">0</span>, n-<span class="hljs-number">1</span>)<br />        trajectory = [RVSA(graph, a, b, p, m) <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>)]<br />        axs[i, j].plot(trajectory)<br />        axs[i, j].set_title(<span class="hljs-string">f&#x27;Starting vertex: <span class="hljs-subst">{start_vertex}</span>&#x27;</span>)<br />plt.show()</span></pre><figure name="90f2" id="90f2" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*rgzf7PinFS_0LQbTmYCLKQ.png" data-width="3151" data-height="3144" src="https://cdn-images-1.medium.com/max/800/1*rgzf7PinFS_0LQbTmYCLKQ.png"><figcaption class="imageCaption">Randomness in trajectory for each iteration</figcaption></figure><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="06a8" id="06a8" class="graf graf--pre graf-after--figure graf--preV2"><span class="pre--content"><span class="hljs-keyword">import</span> random<br /><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br /><br /><span class="hljs-keyword">def</span> <span class="hljs-title function_">RVSA</span>(<span class="hljs-params">graph, a, b, p, m</span>):<br />    <span class="hljs-string">&quot;&quot;&quot;Compute the sum of pseudo-random values associated with the vertices of a graph.&quot;&quot;&quot;</span><br />    n = <span class="hljs-built_in">len</span>(graph)<br />    visited = <span class="hljs-built_in">set</span>()<br />    queue = [random.randint(<span class="hljs-number">0</span>, n-<span class="hljs-number">1</span>)]<br />    total = <span class="hljs-number">0</span><br />    <span class="hljs-keyword">while</span> queue:<br />        vertex = queue.pop(<span class="hljs-number">0</span>)<br />        <span class="hljs-keyword">if</span> vertex <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:<br />            visited.add(vertex)<br />            total += random_value(vertex, a, b, p)<br />            <span class="hljs-keyword">for</span> neighbor <span class="hljs-keyword">in</span> graph[vertex]:<br />                <span class="hljs-keyword">if</span> neighbor <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:<br />                    queue.append(neighbor)<br />    <span class="hljs-keyword">return</span> total % m<br /><br /><span class="hljs-keyword">def</span> <span class="hljs-title function_">random_value</span>(<span class="hljs-params">vertex, a, b, p</span>):<br />    <span class="hljs-string">&quot;&quot;&quot;Generate a pseudo-random value for a given vertex.&quot;&quot;&quot;</span><br />    x = vertex<br />    y = (a*x + b) % p<br />    <span class="hljs-keyword">return</span> y<br /><br /><span class="hljs-comment"># Generate a random graph with 100 vertices and edges with probability 0.5</span><br />n = <span class="hljs-number">100</span><br />graph = [[<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> random.random() &lt; <span class="hljs-number">0.5</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br /><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br />    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br />        <span class="hljs-keyword">if</span> graph[i][j] == <span class="hljs-number">1</span>:<br />            graph[j][i] = <span class="hljs-number">1</span><br /><br /><span class="hljs-comment"># Compute RVSA for a = 3, b = 7, p = 11, m = big prime numbers</span><br />a = <span class="hljs-number">3</span><br />b = <span class="hljs-number">7</span><br />p = <span class="hljs-number">11</span><br />m_values = [<span class="hljs-number">11</span>, <span class="hljs-number">53</span>, <span class="hljs-number">101</span>, <span class="hljs-number">503</span>, <span class="hljs-number">1009</span>, <span class="hljs-number">5003</span>, <span class="hljs-number">10007</span>, <span class="hljs-number">50021</span>, <span class="hljs-number">100003</span>, <span class="hljs-number">500009</span>, <span class="hljs-number">1000003</span>]<br />average_rvsa_values = []<br /><span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> m_values:<br />    rvsa_values = []<br />    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br />        rvsa_values.append(RVSA(graph, a, b, p, m))<br />    average_rvsa_values.append(<span class="hljs-built_in">sum</span>(rvsa_values)/<span class="hljs-built_in">len</span>(rvsa_values))<br /><br /><span class="hljs-comment"># Plot the average RVSA value for different values of m</span><br />plt.plot(m_values, average_rvsa_values)<br />plt.xlabel(<span class="hljs-string">&#x27;m&#x27;</span>)<br />plt.ylabel(<span class="hljs-string">&#x27;Average RVSA value&#x27;</span>)<br />plt.title(<span class="hljs-string">&#x27;Average RVSA value for different values of m&#x27;</span>)<br />plt.show()</span></pre><figure name="e8d9" id="e8d9" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*bl9nqhCdVjyTmHrpAqywPw.png" data-width="576" data-height="453" src="https://cdn-images-1.medium.com/max/800/1*bl9nqhCdVjyTmHrpAqywPw.png"></figure><p name="a119" id="a119" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">Time Complexity:</strong></p><p name="a409" id="a409" class="graf graf--p graf-after--p">The time complexity of the RVSA algorithm depends on the size of the input graph and the number of iterations required to visit all its vertices. Let <code class="markup--code markup--p-code">n</code> be the number of vertices in the graph, and let <code class="markup--code markup--p-code">m</code> be the modulus used for the random values. The time complexity can be analyzed as follows:</p><ul class="postList"><li name="e2f4" id="e2f4" class="graf graf--li graf-after--p">Computing the random values for each vertex takes constant time, so this contributes <code class="markup--code markup--li-code">O(n)</code> to the total time complexity.</li><li name="eef7" id="eef7" class="graf graf--li graf-after--li">Each vertex is visited at most once, and each edge is traversed at most twice (once for each of its endpoints), so the total number of iterations is at most <code class="markup--code markup--li-code">2m</code>. Therefore, the time complexity of the algorithm is <code class="markup--code markup--li-code">O(m)</code>.</li></ul><p name="ee71" id="ee71" class="graf graf--p graf-after--li">The recurrence relation for the time complexity of the RVSA algorithm is:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="r" name="cd26" id="cd26" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-built_in">T</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span> O<span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span><br /><span class="hljs-built_in">T</span><span class="hljs-punctuation">(</span>n<span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span> O<span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">+</span> <span class="hljs-built_in">T</span><span class="hljs-punctuation">(</span>n<span class="hljs-operator">-</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">+</span> O<span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span><br />     <span class="hljs-operator">=</span> <span class="hljs-built_in">T</span><span class="hljs-punctuation">(</span>n<span class="hljs-operator">-</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">+</span> O<span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span></span></pre><p name="2d96" id="2d96" class="graf graf--p graf-after--pre">The solution to this recurrence relation is <code class="markup--code markup--p-code">T(n) = O(n)</code>, which confirms that the algorithm&#39;s time complexity is linear in the number of vertices in the graph.</p><p name="6cdf" id="6cdf" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Conclusion</strong>:</p><p name="7376" id="7376" class="graf graf--p graf-after--p">The Randomized Vertex Sum Algorithm (RVSA) is a powerful tool for computing the sum of pseudo-random values associated with the vertices of a graph. Using concepts from algebra, graph theory, and number theory, this algorithm provides a unique approach to solving problems involving graphs and random values.</p><p name="1bfc" id="1bfc" class="graf graf--p graf-after--p graf--trailing">The RVSA is a promising algorithm with potential applications in various fields, such as network analysis, computational biology, and cryptography. Further research can be done to optimize the algorithm and explore its full potential.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@the_daft_introvert" class="p-author h-card">Vishal Sharma</a> on <a href="https://medium.com/p/f0e1ad5eac97"><time class="dt-published" datetime="2023-03-12T08:41:16.463Z">March 12, 2023</time></a>.</p><p><a href="https://medium.com/@the_daft_introvert/randomized-vertex-sum-algorithm-exploring-the-intersection-of-algebra-graph-theory-and-number-f0e1ad5eac97" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on April 2, 2023.</p></footer></article></body></html>