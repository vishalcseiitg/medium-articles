<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>“FPGA Development Made Easy: A Comprehensive Guide to Vivado and Vitis HLS”</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">“FPGA Development Made Easy: A Comprehensive Guide to Vivado and Vitis HLS”</h1>
</header>
<section data-field="subtitle" class="p-summary">
Field Programmable Gate Arrays (FPGAs) are integrated circuits that can be configured and reconfigured to implement digital logic circuits…
</section>
<section data-field="body" class="e-content">
<section name="872a" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="f421" id="f421" class="graf graf--h3 graf--startsWithDoubleQuote graf--leading graf--title">“FPGA Development Made Easy: A Comprehensive Guide to Vivado and Vitis HLS”</h3><p name="6bc1" id="6bc1" class="graf graf--p graf-after--h3">Field Programmable Gate Arrays (FPGAs) are integrated circuits that can be configured and reconfigured to implement digital logic circuits. FPGA technology provides significant advantages over traditional processors, such as low latency, high throughput, and low power consumption. FPGAs are particularly useful in applications that require real-time processing of large amounts of data, such as digital signal processing, machine learning, and high-performance computing.</p><figure name="cd5e" id="cd5e" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*bZ93-hTrCj63vMDU7Y8Slw.jpeg" data-width="220" data-height="220" src="https://cdn-images-1.medium.com/max/800/1*bZ93-hTrCj63vMDU7Y8Slw.jpeg"><figcaption class="imageCaption"><a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array" data-href="https://en.wikipedia.org/wiki/Field-programmable_gate_array" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">A Spartan FPGA from Xilinx</a></figcaption></figure><p name="09c8" id="09c8" class="graf graf--p graf-after--figure">Vivado is a powerful design suite for FPGA development that allows users to design, verify, and implement FPGA designs. It provides a graphical interface for creating and editing FPGA designs and a suite of tools for synthesis, implementation, and verification.</p><p name="5b5e" id="5b5e" class="graf graf--p graf-after--p">Vitis HLS is a high-level synthesis tool that allows users to write C/C++ code that can be synthesized into FPGA circuits. Vitis HLS enables designers to rapidly prototype and optimize FPGA designs using high-level languages and abstract hardware models, which can significantly reduce development time and effort.</p><p name="2c1a" id="2c1a" class="graf graf--p graf-after--p">In this blog, we will explore the use and handling of Vivado and Vitis HLS, including how to write code that can be synthesized with Vitis HLS, how to generate a bitstream with Vivado, and how to use these tools for debugging, simulation, and timing analysis. We will also discuss the benefits of using Vivado and Vitis HLS for FPGA development and provide some use cases where FPGAs are particularly useful.</p><p name="000b" id="000b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Vivado:</strong></p><p name="b288" id="b288" class="graf graf--p graf-after--p">Vivado is a comprehensive tool suite for FPGA development that allows users to design, verify, and implement FPGA designs. Vivado supports a wide range of FPGA devices from <strong class="markup--strong markup--p-strong">Xilinx</strong> and provides a graphical interface for creating and editing FPGA designs and a suite of synthesis, implementation, and verification tools.</p><figure name="dc6f" id="dc6f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*pSlFqvBymUNNuu6lzstAQw.jpeg" data-width="400" data-height="280" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*pSlFqvBymUNNuu6lzstAQw.jpeg"><figcaption class="imageCaption"><a href="https://www.xilinx.com/news/media-kits/xilinx-brings-breakthrough-to-vivado-design-tools.html" data-href="https://www.xilinx.com/news/media-kits/xilinx-brings-breakthrough-to-vivado-design-tools.html" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Source</a></figcaption></figure><p name="d8ad" id="d8ad" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">Interface and Main Features:</strong> The Vivado interface comprises several panels, including the Project Manager, IP Integrator, Flow Navigator, Design Sources, and the Design Runs panel. The Project Manager panel allows users to create, open, and manage projects, while the IP Integrator panel provides a graphical interface for creating and editing IP blocks. The Flow Navigator panel allows users to navigate through the various stages of the FPGA design flow, including synthesis, implementation, and verification.</p><p name="9f28" id="9f28" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Creating a New Project: </strong>To create a new project in Vivado, first open the Project Manager panel and click on the “Create Project” button. Then, specify the project name, location, and target FPGA device. Next, select the project type, either RTL or IP Integrator, and choose whether to create a new design or import an existing one. Finally, add any required source files, constraints, and IP blocks to the project.</p><p name="869d" id="869d" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Adding Source Files:</strong> In Vivado, users can add source files to the project by clicking the “Add Sources” button in the Design Sources panel. Users can add Verilog, VHDL, or SystemVerilog files and IP cores created using Vivado IP Integrator or third-party tools.</p><p name="1702" id="1702" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Running Synthesis:</strong> To run synthesis in Vivado, users must first ensure that the design sources and constraints are correctly specified. Then, click the “Run Synthesis” button in the Flow Navigator panel. The synthesis tool will analyze the design sources, optimize the logic, and generate a synthesized netlist representing the FPGA design.</p><figure name="2c34" id="2c34" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*H5nq6RuLOsxfHNhblaWJQg.png" data-width="1189" data-height="521" src="https://cdn-images-1.medium.com/max/800/1*H5nq6RuLOsxfHNhblaWJQg.png"><figcaption class="imageCaption">4x4 Matrix Multiplication Hardware Design</figcaption></figure><p name="9b0f" id="9b0f" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">Generating a Bitstream: </strong>To generate a bitstream in Vivado, users must first run implementation to map the synthesized netlist to the target FPGA device. Then, click the “Generate Bitstream” button in the Flow Navigator panel. The bitstream is a binary file that contains the FPGA configuration data and can be loaded onto the FPGA device using a programming tool.</p><p name="977b" id="977b" class="graf graf--p graf-after--p">Debugging, Simulation, and Timing Analysis: Vivado provides several tools for debugging, simulation, and timing analysis of FPGA designs. Users can use the Vivado Logic Analyzer for real-time debugging of the FPGA design or the Vivado Simulator for functional design simulation. Vivado also includes the Vivado Timing Analyzer, which allows users to analyze the timing performance of the design and identify potential timing violations.</p><figure name="1f17" id="1f17" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*QSSkOh5IdVoGWfFJA_6WdA.png" data-width="1920" data-height="1080" src="https://cdn-images-1.medium.com/max/800/1*QSSkOh5IdVoGWfFJA_6WdA.png"><figcaption class="imageCaption">A Summary Report on Vivado</figcaption></figure><p name="55c5" id="55c5" class="graf graf--p graf-after--figure">Vivado is a powerful tool suite for FPGA development that provides a comprehensive set of tools for design, verification, and implementation. Users can create new projects, add source files, run synthesis, and generate a bitstream using the graphical interface. Vivado also includes tools for debugging, simulation, and timing analysis, which can help users optimize their FPGA designs&#39; performance and reliability.</p><p name="e1b3" id="e1b3" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Vitis HLS:</strong></p><p name="7ebe" id="7ebe" class="graf graf--p graf-after--p">Vitis HLS is a high-level synthesis tool that allows users to write C/C++ code that can be synthesized into FPGA circuits. Vitis HLS enables designers to rapidly prototype and optimize FPGA designs using high-level languages and abstract hardware models, which can significantly reduce development time and effort.</p><p name="5075" id="5075" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Interface and Main Features: </strong>The Vitis HLS interface comprises several panels, including the Source, Solution, Reports, and Console panels. The Source panel allows users to write and edit C/C++ code, while the Solution panel provides a graphical interface for managing the synthesis flow. The Reports panel displays the synthesis results, including timing and resource utilization reports, and the Console panel displays the progress and status of the synthesis flow.</p><p name="9bff" id="9bff" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Creating a New Project: </strong>To create a new project in Vitis HLS, first open the Solution panel and click on the “New Project” button. Then, specify the project name, location, and target FPGA device. Next, add any required source files and constraints to the project.</p><p name="1364" id="1364" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Writing C/C++ Code:</strong> In Vitis HLS, users can write C/C++ code in the Source panel using the integrated text editor. Users can also import existing code files from other development environments, such as Visual Studio or Eclipse.</p><p name="eefb" id="eefb" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Annotating Code with Directives:</strong> Users must annotate the code with directives to specify how the C/C++ code should be synthesized into FPGA circuits. Directives are special comments that provide information to the synthesis tool, such as loop unrolling factors, pipeline stages, and memory partitioning. Vitis HLS provides a wide range of directives that can be used to optimize the performance and resource utilization of the FPGA design.</p><p name="bb0e" id="bb0e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Running Synthesis: </strong>To run synthesis in Vitis HLS, users must first ensure that the source files and constraints are correctly specified. Then, click the “Run C Synthesis” button in the Solution panel. The synthesis tool will analyze the annotated C/C++ code, generate a high-level synthesis (HLS) report, and generate a synthesized netlist representing the FPGA design.</p><p name="f1fd" id="f1fd" class="graf graf--p graf-after--p">Debugging, Performance Analysis, and Code Optimization: Vitis HLS provides several tools for FPGA design debugging, performance analysis, and code optimization. Users can use the Vitis HLS Debugger for real-time debugging of the synthesized design or the Vitis HLS Analyzer for performance analysis of the design. Vitis HLS also includes the Vitis HLS Optimizer, which automatically allows users to optimize the annotated code for performance and resource utilization.</p><p name="15a3" id="15a3" class="graf graf--p graf-after--p">Vitis HLS is a powerful tool for FPGA development that allows users to write and synthesize C/C++ code into FPGA circuits. Users can create new projects, write C/C++ code, annotate the code with directives, and run synthesis using the graphical interface. Vitis HLS also includes tools for debugging, performance analysis, and code optimization, which can help users to optimize the performance and resource utilization of their FPGA designs.</p><p name="fb68" id="fb68" class="graf graf--p graf-after--p">In the context of Vitis, the <strong class="markup--strong markup--p-strong">“top function”</strong> refers to the main function in a C/C++ design that is targeted for hardware acceleration using Vitis HLS. The top function is the starting point of the design and is where the inputs and outputs of the design are defined.</p><p name="8bb3" id="8bb3" class="graf graf--p graf-after--p">The top function must be defined with the <code class="markup--code markup--p-code">__attribute__((system))</code> attribute to indicate that it is the top-level function. This attribute tells Vitis HLS to treat the function as the top-level module of the design, which will be synthesized into an FPGA hardware module.</p><p name="7af3" id="7af3" class="graf graf--p graf-after--p">Here is an example of a top function in a Vitis HLS design:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="cpp" name="ab53" id="ab53" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;my_hls_function.h&quot;</span></span><br /><br />__attribute__((system)) <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top_function</span><span class="hljs-params">(<span class="hljs-type">int</span> input1, <span class="hljs-type">int</span> input2, <span class="hljs-type">int</span> *output1, <span class="hljs-type">int</span> *output2)</span> </span>{<br />  <span class="hljs-built_in">my_hls_function</span>(input1, input2, output1, output2);<br />  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br />}</span></pre><p name="a693" id="a693" class="graf graf--p graf-after--pre">In this example, <code class="markup--code markup--p-code">my_hls_function</code> is a custom function that performs hardware acceleration using Vitis HLS. The <code class="markup--code markup--p-code">top_function</code> takes two integer inputs, <code class="markup--code markup--p-code">input1</code> and <code class="markup--code markup--p-code">input2</code>, and two integer pointers, <code class="markup--code markup--p-code">output1</code> and <code class="markup--code markup--p-code">output2</code>, which are used to store the results of the computation. The <code class="markup--code markup--p-code">__attribute__((system))</code> attribute is added before the function declaration to indicate that it is the top-level function.</p><p name="fd12" id="fd12" class="graf graf--p graf-after--p">The top function is the entry point of the Vitis HLS design, and all input and output ports of the hardware module must be connected to the top function. The top function is responsible for initializing required input values and starting the hardware module. Once the hardware module has completed its computation, the top function retrieves the output values and returns them to the software application.</p><p name="c98b" id="c98b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Writing code for synthesis with Vitis HLS:</strong></p><p name="0b46" id="0b46" class="graf graf--p graf-after--p">When writing code that will be synthesized with Vitis HLS, there are several guidelines to keep in mind. Here are some tips for writing code that is efficient, easy to optimize, and portable:</p><ol class="postList"><li name="34d4" id="34d4" class="graf graf--li graf-after--p">Use fixed-point arithmetic instead of floating-point arithmetic. Fixed-point arithmetic is more efficient and uses fewer resources than floating-point arithmetic.</li><li name="9066" id="9066" class="graf graf--li graf-after--li">Use parallelism and pipelining to maximize performance. Vitis HLS can automatically detect and exploit parallelism in the code, but users can also manually annotate the code with directives to optimize parallelism and pipelining.</li><li name="25e7" id="25e7" class="graf graf--li graf-after--li">Minimize memory usage by using data compression, loop tiling, and data reuse. Vitis HLS can automatically partition memory for better performance, but users can also manually annotate the code with directives to optimize memory usage.</li><li name="e198" id="e198" class="graf graf--li graf-after--li">Write code that is portable across different FPGA devices. This can be achieved using standard C/C++ syntax, avoiding vendor-specific extensions, and avoiding hard-coded values.</li></ol><p name="4ff0" id="4ff0" class="graf graf--p graf-after--li">Here are some examples of code that can be synthesized with Vitis HLS:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="cpp" name="0fa3" id="0fa3" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;matrixmul.h&quot;</span></span><br /><br /><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">matrixmul</span><span class="hljs-params">(<br />      <span class="hljs-type">mat_a_t</span> a[MAT_A_ROWS][MAT_A_COLS],<br />      <span class="hljs-type">mat_b_t</span> b[MAT_B_ROWS][MAT_B_COLS],<br />      <span class="hljs-type">result_t</span> res[MAT_A_ROWS][MAT_B_COLS])</span><br /></span>{<br />  <span class="hljs-comment">// Iterate over the rows of the A matrix</span><br />  Row: <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAT_A_ROWS; i++) {<br />    <span class="hljs-comment">// Iterate over the columns of the B matrix</span><br />    Col: <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; MAT_B_COLS; j++) {<br /><br /><br />     <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> HLS PIPELINE II=3</span><br />  <span class="hljs-comment">//#pragma HLS UNROLL</span><br /><br />      res[i][j] = <span class="hljs-number">0</span>;<br />      Product: <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; MAT_B_ROWS; k++) {<br />        res[i][j] += a[i][k] * b[k][j];<br />      }<br />    }<br />  }<br />}</span></pre><p name="6512" id="6512" class="graf graf--p graf-after--pre">This code performs matrix multiplication on two matrices <code class="markup--code markup--p-code">a</code> and <code class="markup--code markup--p-code">b</code> and stores the result in <code class="markup--code markup--p-code">res</code>. The <code class="markup--code markup--p-code">#pragma HLS pipeline II=3</code> directive is added to the pipeline of the outer loops with an initiation interval of 3. This allows the function to process multiple iterations of the outer loops simultaneously, improving the performance of the function.</p><p name="ae28" id="ae28" class="graf graf--p graf-after--p">The <code class="markup--code markup--p-code">#pragma HLS unroll</code> directive is commented out in this code but can be added to unroll the inner loop for further performance improvements.</p><p name="6fca" id="6fca" class="graf graf--p graf-after--p">These directives help Vitis HLS optimize the code for FPGA implementation.</p><p name="250b" id="250b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Test Bench File for this function:</strong></p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="cpp" name="9450" id="9450" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;matrixmul.h&quot;</span></span><br /><br /><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br /><br /><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br /></span>{<br />   <span class="hljs-type">mat_a_t</span> in_mat_a[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>] = {<br />      {<span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>},<br />      {<span class="hljs-number">14</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>},<br />      {<span class="hljs-number">17</span>, <span class="hljs-number">18</span> ,<span class="hljs-number">19</span>}<br />   };<br />   <span class="hljs-type">mat_b_t</span> in_mat_b[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>] = {<br />      {<span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>},<br />      {<span class="hljs-number">24</span>, <span class="hljs-number">25</span>, <span class="hljs-number">26</span>},<br />      {<span class="hljs-number">27</span>, <span class="hljs-number">28</span>, <span class="hljs-number">29</span>}<br />   };<br />   <span class="hljs-type">result_t</span> hw_result[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>], sw_result[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>];<br />   <span class="hljs-type">int</span> err_cnt = <span class="hljs-number">0</span>;<br /><br />   <span class="hljs-comment">// Generate the expected result</span><br />   <span class="hljs-comment">// Iterate over the rows of the A matrix</span><br />   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAT_A_ROWS; i++) {<br />      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; MAT_B_COLS; j++) {<br />         <span class="hljs-comment">// Iterate over the columns of the B matrix</span><br />         sw_result[i][j] = <span class="hljs-number">0</span>;<br />         <span class="hljs-comment">// Do the inner product of a row of A and col of B</span><br />         <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; MAT_B_ROWS; k++) {<br />            sw_result[i][j] += in_mat_a[i][k] * in_mat_b[k][j];<br />         }<br />      }<br />   }<br /><br /><span class="hljs-comment">//#ifdef HW_COSIM</span><br />   <span class="hljs-comment">// Run the AutoESL matrix multiply block</span><br />   <span class="hljs-built_in">matrixmul</span>(in_mat_a, in_mat_b, hw_result);<br /><span class="hljs-comment">//#endif</span><br /><br />   <span class="hljs-comment">// Print result matrix</span><br />   cout &lt;&lt; <span class="hljs-string">&quot;{&quot;</span> &lt;&lt; endl;<br />   <span class="hljs-comment">//cout &lt;&lt; setw(6);</span><br />   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAT_A_ROWS; i++) {<br />      cout &lt;&lt; <span class="hljs-string">&quot;{&quot;</span>;<br />      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; MAT_B_COLS; j++) {<br /><span class="hljs-comment">//#ifdef HW_COSIM</span><br />        <span class="hljs-comment">// cout &lt;&lt; hw_result[i][j];</span><br />         <span class="hljs-comment">// Check HW result against SW</span><br />         <span class="hljs-keyword">if</span> (hw_result[i][j] != sw_result[i][j]) {<br />            err_cnt++;<br />            cout &lt;&lt; <span class="hljs-string">&quot;*&quot;</span>;<br />         }<br /><span class="hljs-comment">//#else</span><br />        cout &lt;&lt; sw_result[i][j];<br /><span class="hljs-comment">//#endif</span><br />         <span class="hljs-keyword">if</span> (j == MAT_B_COLS - <span class="hljs-number">1</span>)<br />            cout &lt;&lt; <span class="hljs-string">&quot;}&quot;</span> &lt;&lt; endl;<br />         <span class="hljs-keyword">else</span><br />            cout &lt;&lt; <span class="hljs-string">&quot;,&quot;</span>;<br />      }<br />   }<br />   cout &lt;&lt; <span class="hljs-string">&quot;}&quot;</span> &lt;&lt; endl;<br /><br /><span class="hljs-comment">//#ifdef HW_COSIM</span><br />   <span class="hljs-keyword">if</span> (err_cnt)<br />      cout &lt;&lt; <span class="hljs-string">&quot;ERROR: &quot;</span> &lt;&lt; err_cnt &lt;&lt; <span class="hljs-string">&quot; mismatches detected!&quot;</span> &lt;&lt; endl;<br />   <span class="hljs-keyword">else</span><br />      cout &lt;&lt; <span class="hljs-string">&quot;Test passed.&quot;</span> &lt;&lt; endl;<br /><span class="hljs-comment">//#endif</span><br />   <span class="hljs-keyword">return</span> err_cnt;<br />}</span></pre><figure name="4ade" id="4ade" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*P_d9ipC6WhF8Zunh4Sq9pA.png" data-width="1920" data-height="1080" src="https://cdn-images-1.medium.com/max/800/1*P_d9ipC6WhF8Zunh4Sq9pA.png"><figcaption class="imageCaption">A synthesis summary report on Vitis_HLS</figcaption></figure><p name="75fd" id="75fd" class="graf graf--p graf-after--figure">Here are some additional resources that can help learn more about Vivado and Vitis HLS:</p><ol class="postList"><li name="9bbb" id="9bbb" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Xilinx documentation: </strong>Xilinx provides extensive documentation on Vivado and Vitis HLS, including user guides, reference manuals, and release notes. These resources can be accessed through the Xilinx website or within the Vivado and Vitis HLS interfaces.</li><li name="db5c" id="db5c" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Xilinx forums:</strong> Xilinx hosts forums where users can ask questions, share tips and tricks, and discuss issues related to Vivado and Vitis HLS. The forums are monitored by Xilinx experts and community members who can provide guidance and support.</li><li name="73b6" id="73b6" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Xilinx training:</strong> Xilinx offers training courses on Vivado and Vitis HLS, ranging from beginner to advanced levels. These courses cover topics such as FPGA architecture, design flow, debugging, and optimization.</li><li name="1234" id="1234" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Online tutorials:</strong> Many online tutorials and guides can help users learn how to use Vivado and Vitis HLS. These tutorials are often provided by community members or third-party companies and can be accessed for free or for a fee.</li></ol><p name="c48e" id="c48e" class="graf graf--p graf-after--li graf--trailing">By leveraging these resources, users can enhance their skills and knowledge of Vivado and Vitis HLS and create more efficient and high-quality FPGA designs.</p></div></div></section><section name="2bb1" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="d2ef" id="d2ef" class="graf graf--p graf--leading">In conclusion, Vivado and Vitis HLS are powerful tools for FPGA development that offer a wide range of features and benefits. Vivado provides a comprehensive design environment for creating and implementing FPGA designs, while Vitis HLS allows for the high-level synthesis of C/C++ code into optimized RTL code. Using these tools together, developers can create efficient and high-performance FPGA designs well-suited for various applications.</p><p name="439f" id="439f" class="graf graf--p graf-after--p">Throughout this blog, we have covered the main features and capabilities of Vivado and Vitis HLS, including creating a new project, writing code, adding directives, and running synthesis. We have also provided some tips and tricks for optimizing code, debugging, and using the tools together for more complex projects.</p><p name="fc41" id="fc41" class="graf graf--p graf-after--p graf--trailing">By using Vivado and Vitis HLS, developers can save time and effort in creating FPGA designs and improve the quality and efficiency of their designs. We encourage readers to try these tools for themselves and provide feedback or ask questions in the comments section. With the resources and support available, anyone can become proficient in FPGA development with Vivado and Vitis HLS.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@the_daft_introvert" class="p-author h-card">Vishal Sharma</a> on <a href="https://medium.com/p/5f30958f60b1"><time class="dt-published" datetime="2023-03-07T06:48:28.826Z">March 7, 2023</time></a>.</p><p><a href="https://medium.com/@the_daft_introvert/fpga-development-made-easy-a-comprehensive-guide-to-vivado-and-vitis-hls-5f30958f60b1" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on April 2, 2023.</p></footer></article></body></html>