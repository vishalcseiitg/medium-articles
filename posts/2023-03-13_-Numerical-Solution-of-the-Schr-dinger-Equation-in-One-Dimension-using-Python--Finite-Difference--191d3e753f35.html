<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>“Numerical Solution of the Schrödinger Equation in One Dimension using Python: Finite Difference…</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">“Numerical Solution of the Schrödinger Equation in One Dimension using Python: Finite Difference…</h1>
</header>
<section data-field="subtitle" class="p-summary">
Introduction:
</section>
<section data-field="body" class="e-content">
<section name="08ea" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="b159" id="b159" class="graf graf--h3 graf--startsWithDoubleQuote graf--leading graf--title">“Numerical Solution of the Schrödinger Equation in One Dimension using Python: Finite Difference and Matrix Diagonalization Methods.”</h3><figure name="6cd8" id="6cd8" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*JeRovd7Y21xnA5GkN_3NUQ.jpeg" data-width="2048" data-height="2048" src="https://cdn-images-1.medium.com/max/800/1*JeRovd7Y21xnA5GkN_3NUQ.jpeg"><figcaption class="imageCaption">AI-generated image by the Author</figcaption></figure><h3 name="fa35" id="fa35" class="graf graf--h3 graf-after--figure">Introduction:</h3><p name="e9d3" id="e9d3" class="graf graf--p graf-after--h3">The Schrödinger equation is a fundamental quantum mechanics equation that describes how a quantum system&#39;s state changes with time. It is a partial differential equation involving the system&#39;s wave function and Hamiltonian. The wave function represents the probability amplitude of finding a particle in a particular state, and the Hamiltonian describes the system&#39;s total energy.</p><p name="1ad7" id="1ad7" class="graf graf--p graf-after--p">Solving the Schrödinger equation is essential for understanding the behavior of quantum systems, such as atoms, molecules, and solid-state materials. In this article, we will show you how to solve the Schrödinger equation in Python using the numerical methods of finite difference and matrix diagonalization.</p><h3 name="4ac0" id="4ac0" class="graf graf--h3 graf-after--p">Numerical Method of Finite Difference:</h3><p name="d717" id="d717" class="graf graf--p graf-after--h3">The finite difference method is a numerical method for approximating the solutions of differential equations. In the case of the Schrödinger equation, we can discretize the wave function and Hamiltonian using a grid of points in space and time. We can then approximate the derivatives of the wave function using finite differences, which involves calculating the difference between neighboring points.</p><p name="31b9" id="31b9" class="graf graf--p graf-after--p">To illustrate the finite difference method, let’s consider the one-dimensional time-independent Schrödinger equation:</p><figure name="f4e2" id="f4e2" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*srQ2Ns_CNO7xhSclYtB8Cg.png" data-width="732" data-height="397" src="https://cdn-images-1.medium.com/max/800/1*srQ2Ns_CNO7xhSclYtB8Cg.png"></figure><p name="f0b1" id="f0b1" class="graf graf--p graf-after--figure">We can then solve the Schrödinger equation by finding the eigenvalues and eigenvectors of the Hamiltonian matrix. The eigenvalues represent the system&#39;s energy levels, while the eigenvectors represent the wave functions.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="03ab" id="03ab" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br /><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br /><span class="hljs-keyword">from</span> scipy.sparse.linalg <span class="hljs-keyword">import</span> eigs<br /><br />hbar = <span class="hljs-number">1</span><br />m = <span class="hljs-number">1</span><br />L = <span class="hljs-number">10</span><br />N = <span class="hljs-number">1000</span><br />x = np.linspace(<span class="hljs-number">0</span>, L, N)<br />dx = x[<span class="hljs-number">1</span>] - x[<span class="hljs-number">0</span>]<br />V = np.zeros(N)<br /><br />H = (-hbar**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*m*dx**<span class="hljs-number">2</span>)) * (np.diag(-<span class="hljs-number">2</span>*np.ones(N)) + np.diag(np.ones(N-<span class="hljs-number">1</span>), <span class="hljs-number">1</span>) + np.diag(np.ones(N-<span class="hljs-number">1</span>), -<span class="hljs-number">1</span>)) + np.diag(V)<br /><br />num_eigs = <span class="hljs-number">5</span><br />eigenvalues, eigenvectors = eigs(H, k=num_eigs, which=<span class="hljs-string">&#x27;SM&#x27;</span>)<br /><br />fig, ax = plt.subplots()<br /><br /><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_eigs):<br />    psi = eigenvectors[:, i].real<br />    ax.plot(x, psi, label=<span class="hljs-string">f&#x27;E=<span class="hljs-subst">{eigenvalues[i].real:<span class="hljs-number">.2</span>f}</span>&#x27;</span>)<br /><br />ax.set_xlabel(<span class="hljs-string">&#x27;Position&#x27;</span>)<br />ax.set_ylabel(<span class="hljs-string">&#x27;Wave function&#x27;</span>)<br />ax.legend()<br /><br />plt.show()</span></pre><figure name="0569" id="0569" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*sUkXZJrdCteCYh3iETMzfQ.png" data-width="587" data-height="432" src="https://cdn-images-1.medium.com/max/800/1*sUkXZJrdCteCYh3iETMzfQ.png"><figcaption class="imageCaption">Image Created by the Author</figcaption></figure><h3 name="1006" id="1006" class="graf graf--h3 graf-after--figure">Matrix Diagonalization Method:</h3><p name="f5e6" id="f5e6" class="graf graf--p graf-after--h3">Another numerical method for solving the Schrödinger equation is matrix diagonalization. This method involves representing the wave function as a linear combination of basis functions and constructing a matrix representation of the Hamiltonian in the basis set. We can then diagonalize the Hamiltonian matrix to find the eigenvalues and eigenvectors.</p><p name="f362" id="f362" class="graf graf--p graf-after--p">To illustrate this method, let’s consider the one-dimensional time-independent Schrödinger equation again, but with non-zero potential energy:</p><figure name="8bb6" id="8bb6" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*fQcCcuzJHy635CfllcNWPw.png" data-width="749" data-height="475" src="https://cdn-images-1.medium.com/max/800/1*fQcCcuzJHy635CfllcNWPw.png"></figure><p name="8ac7" id="8ac7" class="graf graf--p graf-after--figure">We can then diagonalize the Hamiltonian matrix to find the eigenvalues and eigenvectors, which represent the system&#39;s energy levels and wave functions.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="9a9b" id="9a9b" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br /><span class="hljs-keyword">import</span> math<br /><br /><span class="hljs-comment"># Define constants</span><br />m = <span class="hljs-number">1.0</span><br />omega = <span class="hljs-number">1.0</span><br />hbar = <span class="hljs-number">1.0</span><br /><br /><span class="hljs-comment"># Define the number of basis functions</span><br />N = <span class="hljs-number">10</span><br /><br /><span class="hljs-comment"># Define the range of x values</span><br />x_min = -<span class="hljs-number">5.0</span><br />x_max = <span class="hljs-number">5.0</span><br />dx = <span class="hljs-number">0.1</span><br />x = np.arange(x_min, x_max, dx)<br /><br /><span class="hljs-comment"># Define the basis functions</span><br />n = np.arange(N)<br />basis = np.zeros((<span class="hljs-built_in">len</span>(x), N))<br /><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):<br />    basis[:, i] = (m*omega/np.pi/hbar)**<span class="hljs-number">0.25</span>/np.sqrt(<span class="hljs-number">2</span>**n[i]*math.factorial(n[i]))*np.polynomial.hermite.Hermite([<span class="hljs-number">0</span>]*i + [<span class="hljs-number">1</span>])(np.sqrt(m*omega/hbar)*x)*np.exp(-<span class="hljs-number">0.5</span>*m*omega*x**<span class="hljs-number">2</span>/hbar)<br /><br /><span class="hljs-comment"># Construct the Hamiltonian matrix</span><br />H = np.zeros((N, N))<br /><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):<br />    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):<br />        <span class="hljs-keyword">if</span> i == j:<br />            H[i, j] = hbar*omega*(i + <span class="hljs-number">0.5</span>)<br />        <span class="hljs-keyword">elif</span> j == i + <span class="hljs-number">1</span>:<br />            H[i, j] = -<span class="hljs-number">0.5</span>*hbar*np.sqrt((j)/(m*omega))*(np.sqrt(j-<span class="hljs-number">1</span>+(i+<span class="hljs-number">1</span>)%<span class="hljs-number">2</span>))<br />        <span class="hljs-keyword">elif</span> j == i - <span class="hljs-number">1</span>:<br />            H[i, j] = -<span class="hljs-number">0.5</span>*hbar*np.sqrt((j)/(m*omega))*(np.sqrt(j-<span class="hljs-number">1</span>+i%<span class="hljs-number">2</span>))<br /><br /><span class="hljs-comment"># Diagonalize the Hamiltonian matrix</span><br />E, psi_T = np.linalg.eigh(H)<br /><br /><span class="hljs-comment"># Compute the wave functions</span><br />psi = np.zeros((<span class="hljs-built_in">len</span>(x), N))<br /><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):<br />    psi[:, i] = np.dot(basis, psi_T[:, i])<br /><br /><span class="hljs-comment"># Plot the probability density of the first 5 energy levels</span><br />plt.figure(figsize=(<span class="hljs-number">8</span>, <span class="hljs-number">6</span>))<br />plt.plot(x, psi[:, <span class="hljs-number">0</span>]**<span class="hljs-number">2</span>, label=<span class="hljs-string">&#x27;Ground state&#x27;</span>)<br />plt.plot(x, psi[:, <span class="hljs-number">1</span>]**<span class="hljs-number">2</span>, label=<span class="hljs-string">&#x27;First excited state&#x27;</span>)<br />plt.plot(x, psi[:, <span class="hljs-number">2</span>]**<span class="hljs-number">2</span>, label=<span class="hljs-string">&#x27;Second excited state&#x27;</span>)<br />plt.plot(x, psi[:, <span class="hljs-number">3</span>]**<span class="hljs-number">2</span>, label=<span class="hljs-string">&#x27;Third excited state&#x27;</span>)<br />plt.plot(x, psi[:, <span class="hljs-number">4</span>]**<span class="hljs-number">2</span>, label=<span class="hljs-string">&#x27;Fourth excited state&#x27;</span>)<br />plt.legend()<br />plt.xlabel(<span class="hljs-string">&#x27;x&#x27;</span>)<br />plt.ylabel(<span class="hljs-string">&#x27;Probability density&#x27;</span>)<br />plt.show()</span></pre><figure name="8f53" id="8f53" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*baQ3iQh4_VWEn6t15SrgEw.png" data-width="691" data-height="525" src="https://cdn-images-1.medium.com/max/800/1*baQ3iQh4_VWEn6t15SrgEw.png"><figcaption class="imageCaption">Image Created by the Author</figcaption></figure><h3 name="1201" id="1201" class="graf graf--h3 graf-after--figure">Conclusion:</h3><p name="c861" id="c861" class="graf graf--p graf-after--h3">In this article, we have discussed two numerical methods for solving the Schrödinger equation in one dimension using Python: the finite difference method and the matrix diagonalization method. Both methods involve approximating the second derivative of the wave function with a numerical scheme. Still, they differ in how the Hamiltonian is represented and how the eigenvalues and eigenvectors are computed.</p><p name="700d" id="700d" class="graf graf--p graf-after--p">The finite difference method is simple and efficient, and easy to implement. Still, it may not be as accurate as the matrix diagonalization method, especially for complex potentials or systems with strong interactions.</p><p name="01a4" id="01a4" class="graf graf--p graf-after--p graf--trailing">The matrix diagonalization method is more accurate and general and can handle many potentials and interactions. Still, it requires more computational resources and may be more difficult to implement.</p></div></div></section><section name="cb7b" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="2416" id="2416" class="graf graf--h3 graf--leading">References:</h3><ol class="postList"><li name="4928" id="4928" class="graf graf--li graf-after--h3">Griffiths, D. J. (2005). Introduction to Quantum Mechanics (2nd ed.). Pearson Education.</li><li name="568c" id="568c" class="graf graf--li graf-after--li">Tinkham, M. (2004). Group Theory and Quantum Mechanics. Dover Publications.</li><li name="0114" id="0114" class="graf graf--li graf-after--li">Press, W. H., Teukolsky, S. A., Vetterling, W. T., &amp; Flannery, B. P. (2007). Numerical Recipes: The Art of Scientific Computing (3rd ed.). Cambridge University Press.</li><li name="fa4b" id="fa4b" class="graf graf--li graf-after--li">Olver, F. W. J., &amp; Shakiban, C. (2014). Applied Mathematics: A Contemporary Approach. Prentice Hall.</li><li name="5a25" id="5a25" class="graf graf--li graf-after--li graf--trailing">Python Software Foundation. (2021). The Python Language Reference, Version 3.10.0. Available at <a href="https://docs.python.org/3/reference/" data-href="https://docs.python.org/3/reference/" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">https://docs.python.org/3/reference/</a>.</li></ol></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@the_daft_introvert" class="p-author h-card">Vishal Sharma</a> on <a href="https://medium.com/p/191d3e753f35"><time class="dt-published" datetime="2023-03-13T16:56:38.404Z">March 13, 2023</time></a>.</p><p><a href="https://medium.com/@the_daft_introvert/numerical-solution-of-the-schr%C3%B6dinger-equation-in-one-dimension-using-python-finite-difference-191d3e753f35" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on April 2, 2023.</p></footer></article></body></html>