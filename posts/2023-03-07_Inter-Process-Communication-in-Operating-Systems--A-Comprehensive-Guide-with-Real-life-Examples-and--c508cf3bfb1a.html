<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Inter-Process Communication in Operating Systems: A Comprehensive Guide with Real-life Examples and…</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Inter-Process Communication in Operating Systems: A Comprehensive Guide with Real-life Examples and…</h1>
</header>
<section data-field="subtitle" class="p-summary">
Introduction: Inter-Process Communication (IPC) is a crucial aspect of modern operating systems that allows processes to communicate with…
</section>
<section data-field="body" class="e-content">
<section name="7399" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="7044" id="7044" class="graf graf--h3 graf--leading graf--title">Inter-Process Communication in Operating Systems: A Comprehensive Guide with Real-life Examples and Code</h3><p name="c07e" id="c07e" class="graf graf--p graf-after--h3">Introduction: Inter-Process Communication (IPC) is a crucial aspect of modern operating systems that allows processes to communicate with each other. This blog will explore the different IPC mechanisms available in operating systems, along with real-life examples and code snippets.</p><p name="96f8" id="96f8" class="graf graf--p graf-after--p">Section 1: Overview of Inter-Process Communication In this section, we will provide a high-level overview of IPC in operating systems and discuss its importance. We will also briefly discuss the different types of IPC mechanisms and their use cases.</p><p name="378f" id="378f" class="graf graf--p graf-after--p">Section 2: Pipes and FIFOs In this section, we will discuss pipes and FIFOs, two simple IPC mechanisms used to communicate between processes. We will explain how they work, their advantages and disadvantages, and provide real-life examples and code snippets.</p><p name="a590" id="a590" class="graf graf--p graf-after--p">Section 3: Shared Memory In this section, we will dive into shared memory, one of the most popular IPC mechanisms. We will discuss how shared memory works, its advantages and disadvantages, and provide some real-life examples and code snippets.</p><p name="30a8" id="30a8" class="graf graf--p graf-after--p">Section 4: Message Passing In this section, we will explore message passing, another popular IPC mechanism. We will discuss the different types of message passing, such as synchronous and asynchronous, and their use cases. We will also provide some real-life examples and code snippets.</p><p name="3574" id="3574" class="graf graf--p graf-after--p">Section 5: Semaphores and Mutexes In this section, we will discuss the synchronization primitives used to prevent race conditions in IPC. We will explain how they work, their advantages and disadvantages, and provide real-life examples and code snippets.</p><p name="0b28" id="0b28" class="graf graf--p graf-after--p">Section 6: Signals In this section, we will explore signals used to notify processes of events or errors. We will discuss how signals work, their advantages and disadvantages, and provide real-life examples and code snippets.</p><p name="0918" id="0918" class="graf graf--p graf-after--p">Section 7: Sockets In this section, we will discuss sockets, a popular IPC mechanism used for communication across a network. We will discuss the different types of sockets, such as TCP and UDP, and their use cases. We will also provide some real-life examples and code snippets.</p><p name="5b94" id="5b94" class="graf graf--p graf-after--p graf--trailing">Conclusion: In conclusion, IPC is a crucial aspect of modern operating systems, and various mechanisms are available for communication between processes. This blog explored some of the most popular IPC mechanisms, such as pipes and FIFOs, shared memory, message passing, semaphores and mutexes, signals, and sockets. We provided real-life examples and code snippets to help you understand how these mechanisms work. With this knowledge, you should be able to choose the right IPC mechanism for your application and implement it successfully.</p></div></div></section><section name="7ceb" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="ecbf" id="ecbf" class="graf graf--p graf--leading"><strong class="markup--strong markup--p-strong">Introduction:</strong></p><p name="2274" id="2274" class="graf graf--p graf-after--p">Inter-process communication (IPC) is an essential concept in modern operating systems that allow processes to exchange data and synchronize activities. IPC mechanisms enable processes to work together, share resources, and coordinate operations to achieve a common goal. In a world where software applications are becoming more complex and systems are becoming more distributed, understanding IPC is crucial for any software developer or system administrator.</p><figure name="7afe" id="7afe" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*4RXPmUpjD-XPWdrd6sqOkg.png" data-width="750" data-height="342" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*4RXPmUpjD-XPWdrd6sqOkg.png"><figcaption class="imageCaption"><a href="https://www.javatpoint.com/what-is-inter-process-communication" data-href="https://www.javatpoint.com/what-is-inter-process-communication" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Image Source</a></figcaption></figure><p name="130f" id="130f" class="graf graf--p graf-after--figure">This blog will provide a comprehensive guide to IPC in operating systems. We will start with an overview of IPC and its importance and then explore different IPC mechanisms with real-life examples and code snippets. By the end of this blog, you will have a solid understanding of IPC and be able to choose the right machine for your application’s needs.</p><figure name="3fa1" id="3fa1" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*aXp0KpMa8mZ8xdZUvxlFfw.png" data-width="500" data-height="421" src="https://cdn-images-1.medium.com/max/800/1*aXp0KpMa8mZ8xdZUvxlFfw.png"><figcaption class="imageCaption"><a href="https://www.javatpoint.com/what-is-inter-process-communication" data-href="https://www.javatpoint.com/what-is-inter-process-communication" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Image Source</a></figcaption></figure><p name="af33" id="af33" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">Section 1: Overview of Inter-Process Communication</strong></p><p name="9e5d" id="9e5d" class="graf graf--p graf-after--p">Inter-process communication (IPC) is a mechanism that allows multiple processes running on an operating system to communicate and share resources with each other. IPC is an essential concept in modern computing systems because most applications are composed of multiple processes that need to work together to achieve their goals.</p><p name="6d94" id="6d94" class="graf graf--p graf-after--p">IPC enables processes to share data, synchronize activities, and coordinate operations. It enables processes to work independently and yet cooperate seamlessly.</p><p name="af82" id="af82" class="graf graf--p graf-after--p">Different types of IPC mechanisms are available in operating systems, each with advantages and disadvantages. These mechanisms include pipes, FIFOs, shared memory, message passing, semaphores and mutexes, signals, and sockets.</p><p name="9e55" id="9e55" class="graf graf--p graf-after--p">Pipes and FIFOs are used to communicate related processes with a common ancestry. Shared memory is used when two or more processes must share a large amount of data. Message passing is used when processes need to communicate with each other, but they are not related. Semaphores and mutexes prevented race conditions when two or more processes accessed shared resources simultaneously. Signals are used to notify processes of events or errors. Finally, sockets are used for communication across a network between processes running on different systems.</p><p name="f295" id="f295" class="graf graf--p graf-after--p">In the next sections, we will explore each IPC mechanism in detail, with examples and code snippets, to help you understand how and when to use them.</p><p name="0583" id="0583" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Section 2: Pipes and FIFOs</strong></p><p name="2996" id="2996" class="graf graf--p graf-after--p">Pipes and FIFOs are two simple IPC mechanisms used for communication between processes that share a common ancestry. They are commonly used in Unix-based systems, such as Linux and macOS.</p><h3 name="d8fd" id="d8fd" class="graf graf--h3 graf-after--p">Pipes</h3><p name="e280" id="e280" class="graf graf--p graf-after--h3">A pipe is a unidirectional communication channel that enables the transfer of data between two related processes. A pipe has two ends: one for writing data (write end) and one for reading data (read end). The data written by one process can be read by another process. A pipe is a simple way for two related processes to communicate with each other.</p><p name="8baf" id="8baf" class="graf graf--p graf-after--p">The process that creates the pipe is called the parent process, and the two processes that communicate through the pipe are called the child processes. Pipes are created using the <code class="markup--code markup--p-code">pipe()</code> system call, which returns two file descriptors, one for the read end and one for the write end of the pipe.</p><p name="e95d" id="e95d" class="graf graf--p graf-after--p">Here’s an example of how to create and use a pipe in C:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="c" name="361c" id="361c" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br /><br /><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br />    <span class="hljs-type">int</span> fd[<span class="hljs-number">2</span>];<br />    <span class="hljs-type">char</span> buffer[<span class="hljs-number">20</span>];<br /><br />    pipe(fd);<br /><br />    <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) { <span class="hljs-comment">// Child process</span><br />        close(fd[<span class="hljs-number">0</span>]); <span class="hljs-comment">// Close read end</span><br />        write(fd[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;Hello World!&quot;</span>, <span class="hljs-number">13</span>); <span class="hljs-comment">// Write data to pipe</span><br />        close(fd[<span class="hljs-number">1</span>]); <span class="hljs-comment">// Close write end</span><br />    } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// Parent process</span><br />        close(fd[<span class="hljs-number">1</span>]); <span class="hljs-comment">// Close write end</span><br />        read(fd[<span class="hljs-number">0</span>], buffer, <span class="hljs-number">20</span>); <span class="hljs-comment">// Read data from pipe</span><br />        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buffer);<br />        close(fd[<span class="hljs-number">0</span>]); <span class="hljs-comment">// Close read end</span><br />    }<br /><br />    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br />}</span></pre><p name="6a4d" id="6a4d" class="graf graf--p graf-after--pre">In this example, the parent process creates a pipe and forks a child process. The child process writes the string “Hello World!” to the write end of the pipe, and the parent process reads the data from the read end of the pipe and prints it to the console.</p><p name="8d44" id="8d44" class="graf graf--p graf-after--p">Pipes have the advantage of being simple to use and easy to understand. However, they have some limitations, such as being unidirectional, meaning data can only flow in one direction, and their size is limited to the system’s maximum pipe buffer size.</p><h3 name="c7a4" id="c7a4" class="graf graf--h3 graf-after--p">FIFOs</h3><p name="47bb" id="47bb" class="graf graf--p graf-after--h3">A FIFO, or named pipe, is a special type of pipe that enables the communication between unrelated processes. Unlike a pipe, a FIFO is created as a file in the file system and has a name associated with it. A FIFO is bidirectional, meaning data can flow in both directions.</p><p name="18a4" id="18a4" class="graf graf--p graf-after--p">FIFOs are created using the <code class="markup--code markup--p-code">mkfifo()</code> system call, which creates a file in the file system with a name and the properties of a FIFO. Processes can then open the file and communicate with each other.</p><p name="c958" id="c958" class="graf graf--p graf-after--p">Here’s an example of how to create and use a FIFO in C:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="c" name="b469" id="b469" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br /><br /><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br />    <span class="hljs-type">char</span> buffer[<span class="hljs-number">20</span>];<br /><br />    mkfifo(<span class="hljs-string">&quot;myfifo&quot;</span>, <span class="hljs-number">0666</span>);<br /><br />    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;myfifo&quot;</span>, O_RDONLY);<br />    read(fd, buffer, <span class="hljs-number">20</span>);<br />    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buffer);<br /><br />    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br />}</span></pre><p name="b4f5" id="b4f5" class="graf graf--p graf-after--pre">In this example, the process creates a FIFO named “myfifo” and opens it for reading. When another process writes data to the FIFO, this process reads the data and prints it to the console.</p><p name="2518" id="2518" class="graf graf--p graf-after--p">FIFOs have the advantage of being bidirectional, meaning data can flow in both directions and can be used for communication between unrelated processes. However, like pipes, they have a limited buffer size and can block if the buffer is full.</p><p name="7ef9" id="7ef9" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Section 3: Shared Memory</strong></p><p name="5481" id="5481" class="graf graf--p graf-after--p">Shared memory is a mechanism used for communication between processes that need to share a common block of memory. In this mechanism, a region of memory is created that can be accessed by multiple processes. This allows for efficient communication between processes, as data can be accessed directly from memory without the overhead of copying data between processes.</p><p name="e9c2" id="e9c2" class="graf graf--p graf-after--p">Shared memory is created using the <code class="markup--code markup--p-code">shmget()</code> system call, which returns a shared memory identifier. Processes can then attach to the shared memory segment using the <code class="markup--code markup--p-code">shmat()</code> system call, which returns a pointer to the shared memory segment. Processes can read and write to the shared memory segment like any other memory block.</p><p name="8e05" id="8e05" class="graf graf--p graf-after--p">Here’s an example of how to create and use shared memory in C:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="cpp" name="8c79" id="8c79" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/shm.h&gt;</span></span><br /><br /><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br />    <span class="hljs-type">int</span> shmid;<br />    <span class="hljs-type">char</span> *shmaddr;<br />    <span class="hljs-type">int</span> *shared_data;<br /><br />    <span class="hljs-comment">// Create shared memory segment</span><br />    shmid = <span class="hljs-built_in">shmget</span>(IPC_PRIVATE, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>), IPC_CREAT | <span class="hljs-number">0666</span>);<br /><br />    <span class="hljs-comment">// Attach to shared memory segment</span><br />    shmaddr = <span class="hljs-built_in">shmat</span>(shmid, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br /><br />    <span class="hljs-comment">// Set shared data</span><br />    shared_data = (<span class="hljs-type">int</span> *)shmaddr;<br />    *shared_data = <span class="hljs-number">42</span>;<br /><br />    <span class="hljs-comment">// Detach from shared memory segment</span><br />    <span class="hljs-built_in">shmdt</span>(shmaddr);<br /><br />    <span class="hljs-comment">// Attach to shared memory segment again</span><br />    shmaddr = <span class="hljs-built_in">shmat</span>(shmid, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br /><br />    <span class="hljs-comment">// Read shared data</span><br />    shared_data = (<span class="hljs-type">int</span> *)shmaddr;<br />    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Shared data: %d\n&quot;</span>, *shared_data);<br /><br />    <span class="hljs-comment">// Detach from shared memory segment</span><br />    <span class="hljs-built_in">shmdt</span>(shmaddr);<br /><br />    <span class="hljs-comment">// Remove shared memory segment</span><br />    <span class="hljs-built_in">shmctl</span>(shmid, IPC_RMID, <span class="hljs-literal">NULL</span>);<br /><br />    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br />}</span></pre><p name="d28e" id="d28e" class="graf graf--p graf-after--pre">In this example, the process creates a shared memory segment using the <code class="markup--code markup--p-code">shmget()</code> system call and attaches to it using the <code class="markup--code markup--p-code">shmat()</code> system call. The process writes the value 42 to the shared memory segment and then detaches from it. The process then attaches to the shared memory segment again and reads the value 42 from it.</p><p name="6b60" id="6b60" class="graf graf--p graf-after--p">Shared memory is very efficient and fast for communication between processes that need to share large amounts of data. However, it has some disadvantages, such as the need for synchronization to prevent race conditions when multiple processes access the shared memory segment simultaneously.</p><p name="a8c1" id="a8c1" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Section 4: Message Passing</strong></p><p name="7cfb" id="7cfb" class="graf graf--p graf-after--p">Message passing is another popular IPC mechanism used for communication between processes. In message passing, processes communicate by sending messages to each other.</p><p name="9fe6" id="9fe6" class="graf graf--p graf-after--p">There are two types of message passing: synchronous and asynchronous. In synchronous message passing, the sender blocks until the receiver acknowledge receipt of the message. In asynchronous message passing, the sender does not block and continues to execute while the message is being sent.</p><p name="279f" id="279f" class="graf graf--p graf-after--p">Message passing can be implemented using various mechanisms, such as sockets, named pipes, and message queues. In this section, we will focus on message queues.</p><p name="14d3" id="14d3" class="graf graf--p graf-after--p">A message queue is a mechanism used for communication between processes, where messages are stored in a queue until they are received by the receiver process. Messages can be sent to a message queue using the <code class="markup--code markup--p-code">msgsnd()</code> system call and received from a message queue using the <code class="markup--code markup--p-code">msgrcv()</code> system call.</p><p name="1f3c" id="1f3c" class="graf graf--p graf-after--p">Here’s an example of how to use message queues in C:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="cpp" name="1202" id="1202" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br /><br /><span class="hljs-keyword">struct</span> <span class="hljs-title class_">msgbuf</span> {<br />    <span class="hljs-type">long</span> mtype;<br />    <span class="hljs-type">char</span> mtext[<span class="hljs-number">100</span>];<br />};<br /><br /><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br />    <span class="hljs-type">int</span> msqid;<br />    <span class="hljs-type">key_t</span> key;<br />    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">msgbuf</span> message;<br /><br />    <span class="hljs-comment">// Create message queue</span><br />    key = <span class="hljs-built_in">ftok</span>(<span class="hljs-string">&quot;/tmp&quot;</span>, <span class="hljs-string">&#x27;a&#x27;</span>);<br />    msqid = <span class="hljs-built_in">msgget</span>(key, IPC_CREAT | <span class="hljs-number">0666</span>);<br /><br />    <span class="hljs-comment">// Send message to message queue</span><br />    message.mtype = <span class="hljs-number">1</span>;<br />    <span class="hljs-built_in">sprintf</span>(message.mtext, <span class="hljs-string">&quot;Hello, world!&quot;</span>);<br />    <span class="hljs-built_in">msgsnd</span>(msqid, &amp;message, <span class="hljs-built_in">sizeof</span>(message), <span class="hljs-number">0</span>);<br /><br />    <span class="hljs-comment">// Receive message from message queue</span><br />    <span class="hljs-built_in">msgrcv</span>(msqid, &amp;message, <span class="hljs-built_in">sizeof</span>(message), <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br />    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received message: %s\n&quot;</span>, message.mtext);<br /><br />    <span class="hljs-comment">// Remove message queue</span><br />    <span class="hljs-built_in">msgctl</span>(msqid, IPC_RMID, <span class="hljs-literal">NULL</span>);<br /><br />    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br />}</span></pre><p name="8256" id="8256" class="graf graf--p graf-after--pre">In this example, the process creates a message queue using the <code class="markup--code markup--p-code">msgget()</code> system call and sends a message to it using the <code class="markup--code markup--p-code">msgsnd()</code> system call. The process then receives a message from the message queue using the <code class="markup--code markup--p-code">msgrcv()</code> system call and prints it out.</p><p name="6aa3" id="6aa3" class="graf graf--p graf-after--p">Message passing has the advantage of being a flexible and reliable IPC mechanism that can be used for both synchronous and asynchronous communication between processes. However, it has some disadvantages, such as the overhead of copying data between processes and the need for synchronization to prevent race conditions when multiple processes access the message queue simultaneously.</p><p name="e44d" id="e44d" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Section 5: Semaphores and Mutexes</strong></p><p name="f8f4" id="f8f4" class="graf graf--p graf-after--p">In inter-process communication, race conditions can occur when multiple processes access shared resources simultaneously. To prevent race conditions, synchronization primitives such as semaphores and mutexes are used.</p><h3 name="6219" id="6219" class="graf graf--h3 graf-after--p">Semaphores</h3><p name="9e21" id="9e21" class="graf graf--p graf-after--h3">A semaphore is a synchronization primitive that can be used to limit the number of processes accessing a shared resource simultaneously. A semaphore can be in one of two states: locked or unlocked. A process can only access the shared resource if the semaphore is in the unlocked state.</p><p name="e230" id="e230" class="graf graf--p graf-after--p">In Unix-like operating systems, semaphores are implemented using the <code class="markup--code markup--p-code">semaphore.h</code> library. Here&#39;s an example of how to use semaphores in C:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="c" name="5991" id="5991" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/sem.h&gt;</span></span><br /><br /><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br />    <span class="hljs-type">int</span> semid;<br />    <span class="hljs-type">key_t</span> key;<br />    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sembuf</span> <span class="hljs-title">operation</span>;</span><br /><br />    <span class="hljs-comment">// Create semaphore</span><br />    key = ftok(<span class="hljs-string">&quot;/tmp&quot;</span>, <span class="hljs-string">&#x27;a&#x27;</span>);<br />    semid = semget(key, <span class="hljs-number">1</span>, IPC_CREAT | <span class="hljs-number">0666</span>);<br /><br />    <span class="hljs-comment">// Initialize semaphore</span><br />    semctl(semid, <span class="hljs-number">0</span>, SETVAL, <span class="hljs-number">1</span>);<br /><br />    <span class="hljs-comment">// Acquire semaphore</span><br />    operation.sem_num = <span class="hljs-number">0</span>;<br />    operation.sem_op = <span class="hljs-number">-1</span>;<br />    operation.sem_flg = <span class="hljs-number">0</span>;<br />    semop(semid, &amp;operation, <span class="hljs-number">1</span>);<br /><br />    <span class="hljs-comment">// Critical section</span><br />    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is a critical section.\n&quot;</span>);<br />    sleep(<span class="hljs-number">10</span>);<br /><br />    <span class="hljs-comment">// Release semaphore</span><br />    operation.sem_num = <span class="hljs-number">0</span>;<br />    operation.sem_op = <span class="hljs-number">1</span>;<br />    operation.sem_flg = <span class="hljs-number">0</span>;<br />    semop(semid, &amp;operation, <span class="hljs-number">1</span>);<br /><br />    <span class="hljs-comment">// Remove semaphore</span><br />    semctl(semid, <span class="hljs-number">0</span>, IPC_RMID);<br /><br />    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br />}</span></pre><p name="41ad" id="41ad" class="graf graf--p graf-after--pre">In this example, the process creates a semaphore using the <code class="markup--code markup--p-code">semget()</code> system call and initializes it to the unlocked state using the <code class="markup--code markup--p-code">semctl()</code> system call. The process then acquires the semaphore using the <code class="markup--code markup--p-code">semop()</code> system call, enters the critical section, sleeps for 10 seconds, and then releases the semaphore using the <code class="markup--code markup--p-code">semop()</code> system call.</p><h3 name="b803" id="b803" class="graf graf--h3 graf-after--p">Mutexes</h3><p name="b502" id="b502" class="graf graf--p graf-after--h3">A mutex is another synchronization primitive used to prevent race conditions. Unlike a semaphore, a mutex can only be owned by one process at a time. If a process attempts to acquire a mutex already owned by another process, it will block until the mutex is released.</p><p name="79e8" id="79e8" class="graf graf--p graf-after--p">In Unix-like operating systems, mutexes are implemented using the <code class="markup--code markup--p-code">pthread_mutex.h</code> library. Here&#39;s an example of how to use mutexes in C:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="cpp" name="8ef5" id="8ef5" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br /><br /><span class="hljs-type">pthread_mutex_t</span> mutex;<br /><br /><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">thread_function</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> </span>{<br />    <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br /><br />    <span class="hljs-comment">// Critical section</span><br />    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is a critical section.\n&quot;</span>);<br />    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">10</span>);<br /><br />    <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br /><br />    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br />}<br /><br /><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br />    <span class="hljs-type">pthread_t</span> thread1, thread2;<br /><br />    <span class="hljs-comment">// Initialize mutex</span><br />    <span class="hljs-built_in">pthread_mutex_init</span>(&amp;mutex, <span class="hljs-literal">NULL</span>);<br /><br />    <span class="hljs-comment">// Create threads</span><br />    <span class="hljs-built_in">pthread_create</span>(&amp;thread1, <span class="hljs-literal">NULL</span>, thread_function, <span class="hljs-literal">NULL</span>);<br />    <span class="hljs-built_in">pthread_create</span>(&amp;thread2, <span class="hljs-literal">NULL</span>, thread_function, <span class="hljs-literal">NULL</span>);<br /><br />    <span class="hljs-comment">// Wait for threads to finish</span><br />    <span class="hljs-built_in">pthread_join</span>(thread1, <span class="hljs-literal">NULL</span>);<br />    <span class="hljs-built_in">pthread_join</span>(thread2, <span class="hljs-literal">NULL</span>);<br /><br />    <span class="hljs-comment">// Destroy mutex</span><br />    <span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;mutex);<br /><br />    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br />}</span></pre><p name="95bd" id="95bd" class="graf graf--p graf-after--pre">In this example, two threads are created, each attempting to acquire the mutex using the <code class="markup--code markup--p-code">pthread_mutex_lock()</code> function. The first thread to acquire the mutex enters the critical section, sleeps for a random amount of time using the sleep() function, and then releases the mutex using pthread_mutex_unlock(). The second thread will then acquire the mutex and repeat the same process. This ensures that only one thread at a time can execute the critical section, preventing race conditions and ensuring data consistency.</p><p name="e421" id="e421" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Signals</strong> are a form of IPC used to notify processes of events or errors. Signals can be sent to a process from the kernel or from another process. When a signal is sent to a process, the operating system interrupts the process’s normal execution and jumps to a signal handler, a function specified by the process that handles the signal.</p><p name="743d" id="743d" class="graf graf--p graf-after--p">There are many different types of signals, including SIGINT (generated by pressing CTRL+C on the keyboard), SIGTERM (used to request that a process terminate gracefully), and SIGSEGV (generated when a process attempts to access memory it does not have permission to access).</p><p name="ad99" id="ad99" class="graf graf--p graf-after--p">One of the advantages of signals is their simplicity. They are easy to use and require very little overhead. However, they can also be dangerous if not used properly, as they can interrupt a process’s execution at any time, potentially leading to data corruption or other issues.</p><p name="b172" id="b172" class="graf graf--p graf-after--p">Here is an example of using signals in C:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="cpp" name="55ce" id="55ce" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br /><br /><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sigint_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span> </span>{<br />    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received SIGINT signal!\n&quot;</span>);<br />}<br /><br /><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br />    <span class="hljs-comment">// Register the signal handler for SIGINT</span><br />    <span class="hljs-built_in">signal</span>(SIGINT, sigint_handler);<br /><br />    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) {<br />        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Waiting for SIGINT...\n&quot;</span>);<br />        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br />    }<br /><br />    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br />}</span></pre><p name="9a4c" id="9a4c" class="graf graf--p graf-after--pre">In this example, we register a signal handler for the SIGINT signal (generated by pressing CTRL+C on the keyboard). When the signal is received, the signal handler prints a message to the console. The main function then enters an infinite loop, waiting for the SIGINT signal to be generated. When the signal is received, the signal handler is executed, and the message is printed to the console.</p><p name="eda6" id="eda6" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Sockets</strong> are a popular IPC mechanism used for communication across a network. Sockets allow processes on different machines to communicate with each other by sending and receiving messages.</p><p name="4c67" id="4c67" class="graf graf--p graf-after--p">There are two main types of sockets: TCP and UDP. TCP (Transmission Control Protocol) is a reliable, connection-oriented protocol that ensures that all data is received in the correct order and without errors. On the other hand, UDP (User Datagram Protocol) is a connectionless protocol that does not guarantee reliable delivery or ordering of messages but is faster and more efficient.</p><p name="8913" id="8913" class="graf graf--p graf-after--p">One of the advantages of sockets is their flexibility. They can be used to communicate between processes on the same machine and between processes on different machines across a network. Sockets also support a wide range of message types, including text, binary data, and multimedia.</p><p name="f6a4" id="f6a4" class="graf graf--p graf-after--p">Here is an example of using sockets in Python:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="e251" id="e251" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">import</span> socket<br /><br /><span class="hljs-comment"># Create a TCP/IP socket</span><br />sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br /><br /><span class="hljs-comment"># Bind the socket to a specific address and port</span><br />server_address = (<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-number">8080</span>)<br />sock.bind(server_address)<br /><br /><span class="hljs-comment"># Listen for incoming connections</span><br />sock.listen(<span class="hljs-number">1</span>)<br /><br /><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br />    <span class="hljs-comment"># Wait for a connection</span><br />    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Waiting for a connection...&#x27;</span>)<br />    connection, client_address = sock.accept()<br /><br />    <span class="hljs-keyword">try</span>:<br />        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Connection from&#x27;</span>, client_address)<br /><br />        <span class="hljs-comment"># Receive the data in small chunks and retransmit it</span><br />        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br />            data = connection.recv(<span class="hljs-number">16</span>)<br />            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Received {!r}&#x27;</span>.<span class="hljs-built_in">format</span>(data))<br />            <span class="hljs-keyword">if</span> data:<br />                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Sending data back to the client&#x27;</span>)<br />                connection.sendall(data)<br />            <span class="hljs-keyword">else</span>:<br />                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;No more data from&#x27;</span>, client_address)<br />                <span class="hljs-keyword">break</span><br /><br />    <span class="hljs-keyword">finally</span>:<br />        <span class="hljs-comment"># Clean up the connection</span><br />        connection.close()</span></pre><p name="6ca0" id="6ca0" class="graf graf--p graf-after--pre">In this example, we create a TCP/IP socket and bind it to a specific address and port. We then listen for incoming connections and, when a connection is made, receive data from the client in small chunks and retransmit it back to the client. When there is no more data to receive, the connection is closed.</p><p name="7479" id="7479" class="graf graf--p graf-after--p">In conclusion, inter-process communication (IPC) is an essential aspect of modern operating systems that enables processes to communicate and collaborate with each other. There are several IPC mechanisms available, each with its advantages and disadvantages.</p><p name="90ce" id="90ce" class="graf graf--p graf-after--p">Pipes and FIFOs are simple and efficient for communication between related processes, while shared memory offers high-speed communication between unrelated processes. Message passing provides a flexible and reliable way to exchange data between processes, while semaphores and mutexes ensure synchronization and prevent race conditions.</p><p name="8681" id="8681" class="graf graf--p graf-after--p">Signals are useful for notifying processes of events or errors, and sockets are widely used for communication across networks. The choice of IPC mechanism depends on the specific requirements of the application.</p><p name="44fb" id="44fb" class="graf graf--p graf-after--p">Understanding IPC is essential for developers who want to write efficient and scalable applications. By using IPC mechanisms effectively, developers can ensure that their applications are robust and efficient and can easily communicate and collaborate with other processes.</p><p name="bbd0" id="bbd0" class="graf graf--p graf-after--p graf--trailing">In summary, IPC is a critical concept in modern operating systems and is used extensively in applications that require communication between processes. By mastering the different IPC mechanisms available, developers can write efficient and scalable applications to communicate and collaborate with other processes.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@the_daft_introvert" class="p-author h-card">Vishal Sharma</a> on <a href="https://medium.com/p/c508cf3bfb1a"><time class="dt-published" datetime="2023-03-07T05:20:00.401Z">March 7, 2023</time></a>.</p><p><a href="https://medium.com/@the_daft_introvert/inter-process-communication-in-operating-systems-a-comprehensive-guide-with-real-life-examples-and-c508cf3bfb1a" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on April 2, 2023.</p></footer></article></body></html>